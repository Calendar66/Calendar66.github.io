<!DOCTYPE html>
<html lang="en">
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
    
        Calendar's Blog
    
</title>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Index | Calendar’s Blog</title>
<meta name="generator" content="Jekyll v4.3.4">
<meta property="og:title" content="Index">
<meta property="og:locale" content="en_US">
<meta name="description" content="A graduate student majoring in computer graphics from Xiamen University.">
<meta property="og:description" content="A graduate student majoring in computer graphics from Xiamen University.">
<link rel="canonical" href="http://localhost:4000/">
<meta property="og:url" content="http://localhost:4000/">
<meta property="og:site_name" content="Calendar’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="1900-01-01T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Index">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","dateModified":"1900-01-01T00:00:00+08:00","datePublished":"1900-01-01T00:00:00+08:00","description":"A graduate student majoring in computer graphics from Xiamen University.","headline":"Index","name":"Calendar’s Blog","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->


<link rel="shortcut icon" type="image/png" href="/assets/img/favicon.webp">
<style>
@font-face {
    font-family: 'Nunito Sans';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Nunito Sans'),
         url("/assets/fonts/NunitoSans-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Righteous';
    font-style: normal;
    font-weight: 600;
    font-display: optional;
    src: local('Righteous'),
         url("/assets/fonts/Righteous-Regular.woff2") format("woff2");
}

@font-face {
    font-family: 'Lato';
    font-style: normal;
    font-weight: 400;
    font-display: optional;
    src: local('Lato'),
         url("/assets/fonts/Lato-Regular.woff2") format("woff2");
}
</style>

<script src="/assets/js/fontfaceobserver.js" type="text/javascript"></script>
<script type="text/javascript">
    const nunitoObserver = new FontFaceObserver('Nunito Sans');
    const righteousObserver = new FontFaceObserver('Righteous');
    const latoObserver = new FontFaceObserver('Lato');
  
    Promise.all([
        nunitoObserver.load(),
        righteousObserver.load(),
        latoObserver.load(),
    ]).then(function(){
        document.documentElement.className += " fonts-loaded";
    });
</script>

<meta name="baseurl" content="">
<meta name="description" content="A graduate student majoring in computer graphics from Xiamen University.">
        <link rel="preload" href="/assets/img/profile.jpg" as="image">
        <link rel="stylesheet" href="/assets/css/style.css">
        
    </head>
    <body>
        <script type="text/javascript">
            let currentTheme = localStorage.getItem('theme');
        
            document.body.classList[currentTheme === 'dark' ? 'add' : 'remove']('dark-theme');
        </script>
        <canvas id="stars" width="100%" height="100%"></canvas>
        <div class="sidebar sidebar-left">
    <div class="side-banner">
        <h1 class="site-tab">
            <a href="/" class="site-name">
                <img src="/assets/img/icon/house.webp" alt="" loading="lazy">
                <mark>Calendar's Blog</mark>
            </a>
            <button id="btn-brightness" aria-label="brightness-button">
                <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
                <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
            </button>
            <button id="btn-search" aria-label="search-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
            </button>
            <button id="btn-nav" aria-pressed="false" aria-label="menu-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"></path></svg>
            </button>
        </h1>
        <a href="/" class="site-avatar" aria-label="site-avatar">
            <img src="/assets/img/profile.jpg" loading="lazy" alt="homepage" aria-label="homepage-button">
        </a>
    </div>
    <div class="side-info">
        <nav id="navigation">
    
    
    

    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

        
    

    
    
    

    <ul class="nav-list">
<li id="nav-first" aria-label="技术学习">
            <div class="nav-item">
                <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>技术学习</span>
                </a><button class="nav-list-expander" aria-label="toggle items in 技术学习 category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="图像降采样">
                    <div class="nav-item">
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E9%99%8D%E9%87%87%E6%A0%B7.html" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>图像降采样</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="GPU通用计算">
                    <div class="nav-item">
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>GPU通用计算</span>
                        </a><button class="nav-list-expander" aria-label="toggle items in GPU通用计算 category" aria-pressed="false">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                        </button>
</div>
<ul class="nav-list">
<li id="nav-third" aria-label="Vulkan compute shader">
                                <div class="nav-item">
                                    <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/Vulkan%20compute%20shader.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>Vulkan compute shader</span>
                                    </a>
                                </div>
                            </li>
<li id="nav-third" aria-label="integral Image计算">
                                <div class="nav-item">
                                    <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/integral%20Image%E8%AE%A1%E7%AE%97.html" class="nav-list-link nav-sh">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                                        <span>integral Image计算</span>
                                    </a>
                                </div>
                            </li>
</ul>
</li>
</ul>
</li>
<li id="nav-first" aria-label="模糊阴影视效研究">
            <div class="nav-item">
                <a href="/%E6%A8%A1%E7%B3%8A%E9%98%B4%E5%BD%B1%E8%A7%86%E6%95%88%E7%A0%94%E7%A9%B6/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>模糊阴影视效研究</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="2D矢量图元绘制技术研究">
            <div class="nav-item">
                <a href="/2D%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%85%83%E7%BB%98%E5%88%B6%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>2D矢量图元绘制技术研究</span>
                </a>
</div>
</li>
<li id="nav-first" aria-label="EasyVulkan">
            <div class="nav-item">
                <a href="/EasyVulkan/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>EasyVulkan</span>
                </a><button class="nav-list-expander" aria-label="toggle items in EasyVulkan category" aria-pressed="false">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M201.4 342.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 274.7 86.6 137.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"></path></svg>
                </button>
</div>
<ul class="nav-list">
<li id="nav-second" aria-label="VMA">
                    <div class="nav-item">
                        <a href="/EasyVulkan/VMA.html" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>VMA</span>
                        </a>
</div>
</li>
<li id="nav-second" aria-label="Vulkan初始化">
                    <div class="nav-item">
                        <a href="/EasyVulkan/Vulkan%E5%88%9D%E5%A7%8B%E5%8C%96.html" class="nav-list-link nav-sh">
                            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"></path></svg>
                            <span>Vulkan初始化</span>
                        </a>
</div>
</li>
</ul>
</li>
<li id="nav-first" aria-label="Home">
            <div class="nav-item">
                <a href="/" class="nav-list-link nav-lh">
                    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512"><path d="M181.3 32.4c17.4 2.9 29.2 19.4 26.3 36.8L197.8 128h95.1l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3s29.2 19.4 26.3 36.8L357.8 128H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H347.1L325.8 320H384c17.7 0 32 14.3 32 32s-14.3 32-32 32H315.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8l9.8-58.7H155.1l-11.5 69.3c-2.9 17.4-19.4 29.2-36.8 26.3s-29.2-19.4-26.3-36.8L90.2 384H32c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l21.3-128H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h68.9l11.5-69.3c2.9-17.4 19.4-29.2 36.8-26.3zM187.1 192L165.8 320h95.1l21.3-128H187.1z"></path></svg>
                    <span>Home</span>
                </a>
</div>
</li>
</ul>
</nav>
        <div id="contact">
            <hr>
            <h3>Contact</h3>
            <ul class="contact-list">
                
                    <li><a aria-label="My Github" href="https://github.com/Calendar66">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Email" href="mailto:guangzez67@gmaill.com">
                        <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48H48zM0 176V384c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V176L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"></path></svg>
                    </a></li>
                
                
                    <li><a aria-label="My Bilibili" href="https://space.bilibili.com/233488614">
                        <svg viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4552" width="10" height="21"><path d="M253.568 577.6c2.496 18.176 5.056 36.48 7.552 55.36 15.488-11.584 30.272-23.04 45.248-34.304C304.384 596.096 263.296 579.776 253.568 577.6z" p-id="4553"></path><path d="M610.176 577.6c2.496 18.176 5.056 36.48 7.552 55.36 15.488-11.584 30.272-23.04 45.248-34.304C660.992 596.096 619.904 579.776 610.176 577.6z" p-id="4554"></path><path d="M515.648 63.296c-244.224 0-442.176 197.952-442.176 442.176s197.952 442.176 442.176 442.176 442.176-197.952 442.176-442.176S759.872 63.296 515.648 63.296zM490.56 447.36l14.656 0c2.496 0 3.712 0.832 3.712 3.84l0 42.752 0 3.392c-5.888-0.32-11.968-0.512-18.304-0.832L490.624 447.36zM390.464 441.856c1.664 0 2.496 1.024 2.88 3.008 1.536 15.488 2.88 30.592 4.544 46.592-5.888 0.704-11.456 0.832-17.664 1.344-2.176-16.96-4.224-33.472-6.4-50.624C379.584 441.856 385.088 441.856 390.464 441.856zM366.592 444.544c2.368-0.32 1.664 1.664 2.048 3.008 0.512 5.696 1.152 11.072 1.664 16.64 0.832 8.768 2.048 17.152 2.88 25.92l0 3.392-13.632 2.368c-3.008-16.32-5.888-32.448-8.896-49.088C356.032 446.208 361.216 444.992 366.592 444.544zM364.096 603.456c-2.176 7.232-7.232 12.928-13.44 17.664-14.656 11.584-29.76 21.696-47.424 27.584-12.416 4.224-25.088 7.232-38.016 9.28-16.832 2.496-33.984 3.712-51.136 5.376-3.52 0.512-6.912 0-10.624 0-1.664 0-2.176-0.832-2.176-2.496-0.192-7.552-0.832-15.488-1.344-23.36-0.832-10.112-1.856-20.032-3.008-30.08-1.664-14.144-3.392-27.776-5.056-41.856-1.664-14.784-3.712-29.44-5.376-44.096-1.664-14.464-3.008-28.736-5.056-43.072-2.368-16.32-4.544-32.448-7.04-49.088-2.496-19.2-6.208-38.528-11.264-57.344-0.32-0.832 0.512-2.496 1.024-3.008 16.64-6.4 33.152-12.928 49.792-19.712 5.376-2.368 5.888-3.2 5.888 3.84 0 29.76 0 59.392 0.512 89.152 0.32 15.488 0.832 30.976 2.048 46.4 1.344 18.496 3.392 37.312 5.056 56.192 0 0.832 0.512 1.536 0.512 2.048 6.4-0.32 12.608-0.832 18.816-0.832 26.432-0.704 52.288 2.88 77.056 12.608 12.096 4.864 23.872 10.432 34.304 18.304C366.784 583.488 368.768 591.552 364.096 603.456zM386.432 641.984C377.728 598.4 369.28 555.52 360.896 511.616c7.04-0.832 13.824-2.048 20.544-2.88 4.864-0.704 9.92-0.704 14.656-1.152 2.688-0.32 4.352 0.832 4.736 3.392 1.024 6.72 2.176 13.44 3.008 20.544 1.536 11.456 2.496 23.04 3.712 34.496 1.152 10.112 2.176 20.032 3.392 30.08 1.152 10.624 2.496 21.376 3.84 32.448 0.32 3.008 0.832 6.4 1.152 9.728C406.144 639.488 396.544 640.64 386.432 641.984zM458.304 629.376c-8.768-0.832-17.152-1.344-26.432-2.176-7.936-79.872-14.656-160.448-29.76-240.896 4.864-0.512 9.92-1.152 14.976-1.664 5.888-0.32 11.584-0.704 17.472-1.152 4.864-0.32 6.72 0.832 7.04 5.568l2.496 38.016c1.152 17.152 2.496 34.304 3.712 51.456 0.832 12.416 1.344 24.704 2.496 37.184 1.152 13.632 2.496 27.072 3.712 40.512 1.152 9.728 2.048 20.032 2.88 29.76 1.152 10.624 2.368 21.376 3.008 32.448l0.832 9.28C460.8 629.376 459.968 629.696 458.304 629.376zM481.472 447.232c2.176 0 3.008 0.512 3.008 3.008-0.32 6.72 0 13.824 0 20.544l0 25.536c-5.056 0.512-9.6 0.832-14.144 1.152-1.344-16.32-2.496-32.768-3.84-50.304L481.472 447.168zM484.032 644.864c-0.832 0-2.176-1.344-2.176-2.176-1.344-14.656-2.496-29.248-3.84-43.904-1.152-13.44-2.496-27.264-3.712-40.704-1.152-13.824-2.496-27.776-3.712-41.856 0-0.832 0-1.664-0.32-2.88 3.392-0.704 6.4-1.152 9.728-1.152 8.768 0 17.664 0.192 26.432 0.512 2.176 0 3.392 1.664 3.392 3.712 0.192 4.544 0.512 8.768 0.512 13.312 0 20.544-0.32 41.408 0 61.888 0.32 16.64 0.832 32.832 1.152 49.472 0 0.832 0 2.048 0.32 3.84C502.336 644.864 492.928 645.184 484.032 644.864zM847.168 447.36l14.656 0c2.496 0 3.712 0.832 3.712 3.84l0 42.752 0 3.392c-5.888-0.32-11.968-0.512-18.304-0.832L847.232 447.36zM747.072 441.856c1.664 0 2.496 1.024 2.88 3.008 1.536 15.488 2.88 30.592 4.544 46.592-5.888 0.704-11.456 0.832-17.664 1.344-2.176-16.96-4.224-33.472-6.4-50.624C736.128 441.856 741.696 441.856 747.072 441.856zM723.2 444.544c2.368-0.32 1.664 1.664 2.048 3.008 0.512 5.696 1.152 11.072 1.664 16.64 0.832 8.768 2.048 17.152 2.88 25.92l0 3.392-13.632 2.368c-3.008-16.32-5.888-32.448-8.896-49.088C712.576 446.208 717.824 444.992 723.2 444.544zM720.512 603.328c-2.176 7.232-7.232 12.928-13.44 17.664-14.656 11.584-29.76 21.696-47.424 27.584-12.416 4.224-25.088 7.232-38.016 9.28-16.832 2.496-33.984 3.712-51.136 5.376-3.52 0.512-6.912 0-10.624 0-1.664 0-2.176-0.832-2.176-2.496-0.192-7.552-0.832-15.488-1.344-23.36-0.832-10.112-1.856-20.032-3.008-30.08-1.664-14.144-3.392-27.776-5.056-41.856-1.664-14.784-3.712-29.44-5.376-44.096-1.664-14.464-3.008-28.736-5.056-43.072-2.368-16.32-4.544-32.448-7.04-49.088-2.496-19.2-6.208-38.528-11.264-57.344-0.192-0.832 0.704-2.496 1.152-2.88 16.64-6.4 33.152-12.928 49.792-19.712 5.376-2.368 5.888-3.2 5.888 3.84 0 29.76 0 59.392 0.512 89.152 0.32 15.488 0.832 30.976 2.048 46.4 1.344 18.496 3.392 37.312 5.056 56.192 0 0.832 0.512 1.536 0.512 2.048 6.4-0.32 12.608-0.832 18.816-0.832 26.432-0.704 52.288 2.88 77.056 12.608 12.096 4.864 23.872 10.432 34.304 18.304C723.392 583.488 725.376 591.552 720.512 603.328zM743.04 641.984c-8.768-43.584-17.152-86.464-25.536-130.368 7.04-0.832 13.824-2.048 20.544-2.88 4.864-0.704 9.92-0.704 14.656-1.152 2.688-0.32 4.352 0.832 4.736 3.392 1.024 6.72 2.176 13.44 3.008 20.544 1.536 11.456 2.496 23.04 3.712 34.496 1.152 10.112 2.176 20.032 3.392 30.08 1.152 10.624 2.496 21.376 3.84 32.448 0.32 3.008 0.832 6.4 1.152 9.728C762.752 639.488 753.152 640.64 743.04 641.984zM814.848 629.376c-8.768-0.832-17.152-1.344-26.432-2.176-7.936-79.872-14.656-160.448-29.76-240.896 4.864-0.512 9.92-1.152 14.976-1.664 5.888-0.32 11.584-0.704 17.472-1.152 4.864-0.32 6.72 0.832 7.04 5.568l2.496 38.016c1.152 17.152 2.496 34.304 3.712 51.456 0.832 12.416 1.344 24.704 2.496 37.184 1.152 13.632 2.496 27.072 3.712 40.512 1.152 9.728 2.048 20.032 2.88 29.76 1.152 10.624 2.368 21.376 3.008 32.448l0.832 9.28C817.408 629.376 816.576 629.696 814.848 629.376zM838.08 447.232c2.176 0 3.008 0.512 3.008 3.008-0.32 6.72 0 13.824 0 20.544l0 25.536c-5.056 0.512-9.6 0.832-14.144 1.152-1.344-16.32-2.496-32.768-3.84-50.304L838.08 447.168zM840.64 644.864c-0.832 0-2.176-1.344-2.176-2.176-1.344-14.656-2.496-29.248-3.84-43.904-1.152-13.44-2.496-27.264-3.712-40.704-1.152-13.824-2.496-27.776-3.712-41.856 0-0.832 0-1.664-0.32-2.88 3.392-0.704 6.4-1.152 9.728-1.152 8.768 0 17.664 0.192 26.432 0.512 2.176 0 3.392 1.664 3.392 3.712 0.192 4.544 0.512 8.768 0.512 13.312 0 20.544-0.32 41.408 0 61.888 0.32 16.64 0.832 32.832 1.152 49.472 0 0.832 0 2.048 0.32 3.84C858.944 644.864 849.536 645.184 840.64 644.864z" p-id="4555"></path></svg>                
                
                
                
            </a></li>
</ul>
            <hr>
            <span>
                Copyright © 2025 | <a href="/">Calendar</a>
            </span>
        </div>
    </div>
</div>
<div class="sidebar sidebar-right">
    <div class="tools">
        <button id="btn-brightness" aria-label="brightness-button">
            <svg class="ico-dark" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path></svg>
            <svg class="ico-light" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path></svg>
        </button>
        <button id="btn-search" aria-label="search-button">
            <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg>
        </button>
    </div>
</div>
        <div id="post">
            <div class="inner-header">
                <span class="dot" style="background-color: #F86158;"></span>
                <span class="dot" style="background-color: #FBBF2D;"></span>
                <span class="dot" style="background-color: #2ACB45;"></span>
            </div>
            <div class="inner-content">
                <div class="category-tree">
<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 576 512"><path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path></svg>
    <p>
                <a href="/">Home</a>
                &gt;
            </p>
</div>
                
                    <div id="loading">
    <div class="loading_box">
        <img src="/assets/img/loading.webp" loading="lazy">
        <p>Now Loading ...</p>
    </div>
</div>
                    <h1 class="category-header">
    
        All Posts
    
</h1>
<div id="category-list">
    <ul class="paginated-list" data-current-page="1" aria-live="polite">
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/EasyVulkan/VMA.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('https://docs.vulkan.org/guide/latest/_images/memory_allocation_sub_allocation.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/EasyVulkan/VMA.html"><h1 class="title_post">VMA</h1></a>
                        <a href="/EasyVulkan/VMA.html" class="txt_post">
                            引言：为何需要VMA？

Vulkan内存显式控制

在传统的图形API（如OpenGL）中，内存管理被API层完全封装，开发者无需关心底层细节。但Vulkan将内存控制权完全下放给开发者，暴露了显式的内存管理机制。这种设计带来了两个核心挑战：


  多类型内存堆：现代GPU通常包含4-8种内存类型（如DEVICE_LOCAL、HOST_VISIBLE等），分布在不同的内存堆中
  手动生命周期管理：开发者需要自行处理内存分配、绑定、映射和释放的全过程


一个典型的Vulkan内存分配流程需要：

vkGetBufferMemoryRequirements(...);
vkAllocateMemory(...);
vkBindBufferMemory(...);
vkMapMemory(...); // 可选
// 使用内存...
vkDestroyBuffer(...);
vkFreeMemory(...);


这种显式控制虽然提升了性能，但带来了极高的开发复杂度。根据Khronos的统计，超过60%的Vulkan内存相关BUG源于不正确的内存类型选择或生命周期管理。

Sub-allocation

  考虑驱动开销：Vulkan最推荐使用sub-allocat，但是sub-allocation的内存分配原则，即尽可能减少Memory和Buffer的数量。





图 1：sub-allocation。



“The Good” ——在一大块内存里对子资源进行子分配
思路：
	•	只向驱动/操作系统申请一块较大的 VkDeviceMemory，只创建一个buffer；
	•	运行时将该buffer“切割”成若干子区间，每个子区间存储不同的数据。
	•	这样可以显著减少真正的“分配调用次数”，也不会超出 maxMemoryAllocationCount，同时也可以减少内存绑定次数。

// 1. 创建一个“大 Buffer”以获取内存需求（包含所有用途）
VkBufferCreateInfo bigBufferCI = {};
bigBufferCI.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
bigBufferCI.size  = totalBufferSize; // 总大小（包含 Index/Vertex/Uniform）
bigBufferCI.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT |
                    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |
                    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
vkCreateBuffer(device, &amp;bigBufferCI, nullptr, &amp;bigBuffer);

VkMemoryRequirements memReqBigBuffer;
vkGetBufferMemoryRequirements(device, bigBuffer, &amp;memReqBigBuffer);

// 2. 计算各用途的偏移和对齐
VkDeviceSize offsetIndex   = 0;
VkDeviceSize offsetVertex  = AlignUp(offsetIndex + indexBufferSize, memReqBigBuffer.alignment);
VkDeviceSize offsetUniform = AlignUp(offsetVertex + vertexBufferSize, memReqBigBuffer.alignment);
VkDeviceSize totalSize     = AlignUp(offsetUniform + uniformBufferSize, memReqBigBuffer.alignment);

// 3. 只申请一次设备内存
VkMemoryAllocateInfo allocInfo = {};
allocInfo.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize  = totalSize;
allocInfo.memoryTypeIndex = FindMemoryType(memReqBigBuffer.memoryTypeBits, desiredProperties);
VkDeviceMemory bigMemory;
vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;bigMemory);

// 4. 将整个 bigMemory 绑定到“大 Buffer”
vkBindBufferMemory(device, bigBuffer, bigMemory, 0);

// 5. 将数据拷贝到 Buffer 的不同偏移处
void* mappedMemory = nullptr;
vkMapMemory(device, bigMemory, 0, VK_WHOLE_SIZE, 0, &amp;mappedMemory);

// -- 将 Index 数据拷贝到对应偏移
std::memcpy((uint8_t*)mappedMemory + offsetIndex, localIndexData, indexBufferSize);

// -- 将 Vertex 数据拷贝到对应偏移
std::memcpy((uint8_t*)mappedMemory + offsetVertex, localVertexData, vertexBufferSize);

// -- 将 Uniform 数据拷贝到对应偏移
std::memcpy((uint8_t*)mappedMemory + offsetUniform, localUniformData, uniformBufferSize);

vkUnmapMemory(device, bigMemory);

// 6. 使用时指定偏移
// -- 绑定 Index Buffer
vkCmdBindIndexBuffer(cmdBuffer, bigBuffer, offsetIndex, VK_INDEX_TYPE_UINT16);

// -- 绑定 Vertex Buffer
VkDeviceSize vertexBufferOffset = offsetVertex;
vkCmdBindVertexBuffers(cmdBuffer, 0, 1, &amp;bigBuffer, &amp;vertexBufferOffset);

// -- 更新 DescriptorSet，指定 Uniform Buffer 的偏移和范围
VkDescriptorBufferInfo uniformBufferInfo = {};
uniformBufferInfo.buffer = bigBuffer;
uniformBufferInfo.offset = offsetUniform;
uniformBufferInfo.range  = uniformBufferSize;

VkWriteDescriptorSet writeDesc = {};
writeDesc.sType            = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
writeDesc.dstSet           = descriptorSet;
writeDesc.dstBinding       = uniformBinding;
writeDesc.descriptorType   = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
writeDesc.descriptorCount  = 1;
writeDesc.pBufferInfo      = &amp;uniformBufferInfo;

vkUpdateDescriptorSets(device, 1, &amp;writeDesc, 0, nullptr);


这种方式：
	•	减少 vkAllocateMemory / vkBindBufferMemory 调用次数（只分配和绑定一次）；
	•	通过应用层自己维护 offset 来在同一个 Buffer 内划分出 Index/Vertex/Uniform 等数据区域；
	•	大幅降低驱动层管理负担，符合 Vulkan 中鼓励的“子分配”思路，从而达到图示所说的 “The Good”。

“The Bad” ——单块显存 + 单个大 Buffer + 手动管理 offset
思路：
	•	只向驱动/操作系统申请一块较大的 VkDeviceMemory；
	•	运行时将这块大内存“切割”成若干子区间，每个子区间绑定到不同的 Buffer（如 Index/Vertex/Uniform）上；
	•	自己管理这块内存中各个子区间的偏移与大小。
	•	这样可以显著减少真正的“分配调用次数”，也不会超出 maxMemoryAllocationCount。

// 1. 分别创建需要的 Buffer 以获取各自需求（但先不真正分配内存）
// -- 例子：Index Buffer
VkBufferCreateInfo indexBufferCI = {};
indexBufferCI.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
indexBufferCI.size  = indexBufferSize;
indexBufferCI.usage = VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
vkCreateBuffer(device, &amp;indexBufferCI, nullptr, &amp;indexBuffer);

VkMemoryRequirements memReqIndex;
vkGetBufferMemoryRequirements(device, indexBuffer, &amp;memReqIndex);

// -- 例子：Vertex Buffer
VkBufferCreateInfo vertexBufferCI = {};
vertexBufferCI.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
vertexBufferCI.size  = vertexBufferSize;
vertexBufferCI.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
vkCreateBuffer(device, &amp;vertexBufferCI, nullptr, &amp;vertexBuffer);

VkMemoryRequirements memReqVertex;
vkGetBufferMemoryRequirements(device, vertexBuffer, &amp;memReqVertex);

// -- 例子：Uniform Buffer
VkBufferCreateInfo uniformBufferCI = {};
uniformBufferCI.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
uniformBufferCI.size  = uniformBufferSize;
uniformBufferCI.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
vkCreateBuffer(device, &amp;uniformBufferCI, nullptr, &amp;uniformBuffer);

VkMemoryRequirements memReqUniform;
vkGetBufferMemoryRequirements(device, uniformBuffer, &amp;memReqUniform);

// 2. 计算总共需要的内存大小与对齐（实际需要根据对齐做更严谨的计算）
// 比如令 offsets 为对齐后得到的各个起始偏移
VkDeviceSize offsetIndex   = 0;
VkDeviceSize offsetVertex  = AlignUp(offsetIndex   + memReqIndex.size,   memReqVertex.alignment);
VkDeviceSize offsetUniform = AlignUp(offsetVertex  + memReqVertex.size,  memReqUniform.alignment);
VkDeviceSize totalSize     = offsetUniform + memReqUniform.size;

// 3. 只申请一次设备内存
VkMemoryAllocateInfo allocInfo = {};
allocInfo.sType           = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize  = totalSize;
allocInfo.memoryTypeIndex = FindMemoryType(
    memReqIndex.memoryTypeBits &amp; memReqVertex.memoryTypeBits &amp; memReqUniform.memoryTypeBits, 
    desiredProperties // 比如 HOST_VISIBLE | HOST_COHERENT 等
);
VkDeviceMemory bigMemory;
vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;bigMemory);

// 4. 将同一个 bigMemory 不同的偏移绑定给不同 Buffer
vkBindBufferMemory(device, indexBuffer,   bigMemory, offsetIndex);
vkBindBufferMemory(device, vertexBuffer,  bigMemory, offsetVertex);
vkBindBufferMemory(device, uniformBuffer, bigMemory, offsetUniform);


这样所有的 Index/Vertex/Uniform Buffer 都共享了同一个 VkDeviceMemory，而我们只跟驱动真正打了一次“分配”的交道。

“The ?!? # Δt” ——极度碎片化或疯狂分配
思路：
	•	每个小对象都单独分配，甚至更糟：同一个对象反复频繁地分配和释放；
	•	导致显存碎片化、分配次数超标、或大幅度浪费显存；

典型反面案例：
	•	你的场景中有非常多的微小 Buffer（例如粒子、分块地形中大量细分）却从未做子分配；
	•	或者在帧间频繁地 vkFreeMemory / vkAllocateMemory，引起驱动层不断地做大开销的操作；
	•	在高并发或高频率下，性能和可用内存都崩溃式下降。

数据传输
独立显卡
有专用的显存(VRAM)
数据传输过程：

  CPU (Host) → PCIe总线 → GPU显存(Device Local Memory)
  需要创建staging buffer作为中间缓冲
  数据传输会受限于PCIe总线带宽


集成显卡
CPU和GPU共享系统内存
数据传输过程：

  直接在共享内存中访问,无需跨PCIe传输
  不需要staging buffer
  通过VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT 标识


Lazily Allocated Memory
移动端GPU上的on-chip memory

  这种内存不会立即分配物理内存
  通常用于移动设备的 transient attachments（如深度缓冲区）
  实际的内存分配会推迟到真正需要时
  在某些架构上可能完全不会分配物理内存
这种内存在渲染时可以被保留在GPU上，显著降低带宽。



  补充内容，VMA相关请跳转到“VMA的诞生”


补充：VkPhysicalDeviceMemoryProperties

typedef struct VkPhysicalDeviceMemoryProperties {
    // 可用的内存类型数量
    uint32_t memoryTypeCount;

    // 内存类型数组，最大长度为 VK_MAX_MEMORY_TYPES (32)
    VkMemoryType memoryTypes[VK_MAX_MEMORY_TYPES];

    // 可用的内存堆数量
    uint32_t memoryHeapCount;

    // 内存堆数组，最大长度为 VK_MAX_MEMORY_HEAPS (16)
    VkMemoryHeap memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;


memoryTypeCount指明该设备支持的内存类型数量。

VkMemoryType
其中 VkMemoryType 结构体定义为：

typedef struct VkMemoryType {
    // 内存属性标志（VkMemoryPropertyFlags）
    VkMemoryPropertyFlags propertyFlags;

    // 此内存类型使用的堆的索引
    uint32_t heapIndex;
} VkMemoryType;


一个VkMemoryType结构体对应GPU支持的一种内存类型，比如：

// memoryTypes[0] - 设备本地内存（VRAM）
propertyFlags = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
heapIndex = 0  // 指向VRAM堆

// memoryTypes[1] - CPU可见的系统内存
propertyFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | 
               VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
heapIndex = 1  // 指向系统内存堆

// memoryTypes[2] - CPU可见且带缓存的系统内存
propertyFlags = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | 
               VK_MEMORY_PROPERTY_HOST_CACHED_BIT
heapIndex = 1  // 同样指向系统内存堆

VkMemoryPropertyFlags的常见值包括：

typedef enum VkMemoryPropertyFlagBits {
    // 设备本地内存，通常是GPU最高效的内存类型
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,

    // CPU可见内存，可以使用vkMapMemory映射
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,

    // CPU写入立即可见，不需要手动flush
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,

    // CPU写入被缓存，需要手动flush和invalidate
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,

    // 用于tile-based GPU的延迟分配内存
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000020,

    // 受保护的内存，用于安全内容
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000040,

    // RDMA可访问的内存
    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040,

    // 设备本地且RDMA可访问
    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080,

    // 可以原子访问的RDMA内存
    VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV = 0x00000100,
} VkMemoryPropertyFlagBits;

常见的内存标识(flag常见组合)：

VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT //设备本地内存（GPU 专用）

VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | 
VK_MEMORY_PROPERTY_HOST_COHERENT_BIT //CPU 可见的暂存缓冲区

VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | 
VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT //集成显卡的共享内存

VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | 
VK_MEMORY_PROPERTY_HOST_CACHED_BIT //带缓存的 CPU 访问内存

VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT | 
VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT //移动设备的临时附件（如深度缓冲）


VkMemoryHeap
typedef struct VkMemoryHeap {
    VkDeviceSize    size;        // 堆的大小（字节）
    VkMemoryHeapFlags    flags;  // 堆的属性标志
} VkMemoryHeap;


VkMemoryHeapFlags的常见值包括：

VK_MEMORY_HEAP_DEVICE_LOCAL_BIT //设备本地内存（通常是显卡的 VRAM）
VK_MEMORY_HEAP_MULTI_INSTANCE_BIT //多实例内存（在多 GPU 设置中，标记某个内存堆可以被多个物理设备同时访问）


findMemoryType

uint32_t findMemoryType(VkPhysicalDevice physicalDevice, 
                       uint32_t typeFilter,
                       VkMemoryPropertyFlags properties) {
    // 获取物理设备的内存属性
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &amp;memProperties);

    // 遍历所有内存类型
    for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) {
        // 检查两个条件：
        // 1. typeFilter 中的位是否设置 (通过位运算)
        // 2. 内存类型是否具有我们需要的所有属性
        if ((typeFilter &amp; (1 &lt;&lt; i)) &amp;&amp; 
            (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) {
            return i;
        }
    }

    // 如果没找到合适的内存类型，抛出错误
    throw std::runtime_error("failed to find suitable memory type!");
}

// 创建缓冲区时
VkBuffer buffer;
VkBufferCreateInfo bufferInfo = {...};
vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;buffer);

// 获取缓冲区的内存需求
VkMemoryRequirements memRequirements;
vkGetBufferMemoryRequirements(device, buffer, &amp;memRequirements);

// 分配内存
VkMemoryAllocateInfo allocInfo = {};
allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
allocInfo.allocationSize = memRequirements.size;
// 查找合适的内存类型
allocInfo.memoryTypeIndex = findMemoryType(
    physicalDevice,
    memRequirements.memoryTypeBits,  // typeFilter：缓冲区支持的内存类型
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT  // 所需属性
);


在为缓冲区分配内存时，需要满足：

  缓冲区支持的内存类型（typeFilter）
  所需属性（properties）
即在VkPhysicalDeviceMemoryProperties中找到一个内存类型，它满足typeFilter和properties的要求。


VMA的诞生
Vulkan Memory Allocator（VMA）库应运而生，它通过以下核心设计解决了上述痛点：


  智能内存类型选择：基于资源使用特性自动选择最佳内存类型
  生命周期自动化：统一管理资源对象及其关联内存的生命周期
  高级内存策略：提供内存池、碎片整理等高级功能
  诊断工具集成：内置内存统计、泄漏检测等调试功能


初始化：构建内存管理基石

环境配置
使用VMA需要：

  
    项目集成：要在项目中使用VMA，首先需要将其源代码或库文件包含进工程中，并正确链接(link)。
  
  
    选择Vulkan版本：VMA需要配置Vulkan的目标版本，以便启用或禁用特定的Vulkan函数和扩展。
  
  
    导入Vulkan函数：VMA自身需要调用大量Vulkan函数，这些函数需通过VmaVulkanFunctions结构体向VMA提供。可通过手动设置或者自动加载方式(如使用Vulkan loader)来实现。
  
  
    启用扩展：如果需要使用诸如VK_KHR_dedicated_allocation等Vulkan扩展，则需要在创建VmaAllocator时告知VMA以便充分利用这些扩展。
  
  
    配置选项：在初始化VMA时，可指定各种标志(Flags)与配置，如线程安全(是否启用互斥锁)等。
  


初始化流程
#include "vk_mem_alloc.h"

VmaAllocatorCreateInfo allocatorInfo = {};
allocatorInfo.vulkanApiVersion = VK_API_VERSION_1_2;
allocatorInfo.physicalDevice = physicalDevice;
allocatorInfo.device = device;
allocatorInfo.instance = instance;

VmaAllocator allocator;
vmaCreateAllocator(&amp;allocatorInfo, &amp;allocator);


关键配置项说明：
typedef struct VmaAllocatorCreateInfo {
    VkPhysicalDevice physicalDevice;
    VkDevice device;
    // 启用高级特性
    VmaAllocatorCreateFlags flags;
    // 自定义CPU内存分配器
    const VmaAllocationCallbacks* pAllocationCallbacks;
    // 设备内存限制
    VkDeviceSize heapSizeLimit[VK_MAX_MEMORY_HEAPS];
} VmaAllocatorCreateInfo;


推荐开启的标志位：

  VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT：支持设备地址捕获
  VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT：显存预算监控


AllocatorCreateInfo中的flags：

VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT

  表示在多线程环境下，由用户负责同步
  可以提高性能，但需要用户确保分配器的线程安全
  如果设置此标志，用户必须在外部进行同步，确保对同一个 VmaAllocator 的调用不会并发执行


VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT

  启用 VK_KHR_dedicated_allocation 扩展功能
  允许为某些特定资源分配专用内存块
  适用于大型资源(如大纹理)的优化


VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT

  启用 VK_KHR_bind_memory2 扩展
  提供更灵活的内存绑定选项
  允许一次绑定多个内存对象


VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT

  启用 VK_EXT_memory_budget 扩展
  允许查询当前内存使用情况和预算
  有助于更好地管理内存资源


VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT

  启用 VK_AMD_device_coherent_memory 扩展
  支持 AMD 设备一致性内存
  提供更高效的内存访问


VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT

  启用缓冲区设备地址功能
  支持 VK_KHR_buffer_device_address 扩展
  允许在着色器中直接访问缓冲区


VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT

  启用 VK_EXT_memory_priority 扩展
  允许设置内存分配的优先级
  有助于优化内存管理策略


基础功能：从入门到精通

1. 资源生命周期管理
缓冲区创建范例：
VkBufferCreateInfo bufferInfo = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
bufferInfo.size = 1024 * 1024; // 1MB
bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;

VmaAllocationCreateInfo allocInfo = {};
allocInfo.usage = VMA_MEMORY_USAGE_AUTO;
allocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;

VkBuffer buffer;
VmaAllocation allocation;
vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);


内存使用策略枚举：
typedef enum VmaMemoryUsage {
    VMA_MEMORY_USAGE_UNKNOWN = 0,
    VMA_MEMORY_USAGE_GPU_ONLY,        // 纯设备内存
    VMA_MEMORY_USAGE_CPU_ONLY,        // 可映射主机内存
    VMA_MEMORY_USAGE_CPU_TO_GPU,      // 频繁上传
    VMA_MEMORY_USAGE_GPU_TO_CPU,      // 回读数据
    VMA_MEMORY_USAGE_AUTO = 7         // 自动决策（推荐）
} VmaMemoryUsage;


VmaAllocationCreateFlags 枚举值说明：

VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT

  指示内存将被主机按顺序写入
  适用于单次或连续写入的缓冲区
  可能影响内存类型选择以优化顺序访问


VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT

  指示内存将被主机随机读写访问
  适用于需要频繁更新的动态缓冲区
  会选择支持随机访问的内存类型


VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT

  当主机直接访问不可用时允许使用传输操作
  提供内存访问的备选方案
  增加分配的灵活性


VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT

  强制为此分配使用独立的内存块
  适用于大型资源或特殊用途
  可能增加内存碎片


VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT

  仅在现有内存块中查找空间
  如果没有合适的空间则失败
  用于严格控制内存分配


VMA_ALLOCATION_CREATE_MAPPED_BIT

  创建时自动执行内存映射
  避免手动映射/解映射操作
  适用于需要持续访问的资源


VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT

  为用户数据创建字符串的深拷贝
  确保字符串数据的独立性和安全性
  方便资源追踪和调试


VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT

  尝试在较高的 GPU 地址空间分配
  可能影响某些特定硬件的性能
  用于特殊的内存布局需求


内存分配策略标志

  VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT
  VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT
  VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT
用于控制内存分配算法的选择，影响分配效率和内存碎片


2. 内存映射与访问
安全的内存访问模式：
void* mappedData;
vmaMapMemory(allocator, allocation, &amp;mappedData);

// 写入数据（建议使用memcpy而非直接指针操作）
memcpy(mappedData, sourceData, dataSize);

vmaUnmapMemory(allocator, allocation);


持久映射优化技巧：
allocInfo.flags |= VMA_ALLOCATION_CREATE_MAPPED_BIT;
// 创建后直接访问
VmaAllocationInfo allocInfo;
vmaGetAllocationInfo(allocator, allocation, &amp;allocInfo);
void* persistentPtr = allocInfo.pMappedData;



  1.使用VMA进行数据拷贝时无需创建和操作staging buffer，VMA会自动选择最佳内存类型，并进行数据传输。（依赖于创建buffer时正确指定usage和flags）
2.对于 Host 可见的内存，VMA 也提供 vmaFlushAllocation, vmaInvalidateAllocation 等接口，用于在需要时清理或无效化 CPU/GPU 缓存，确保数据一致性。


高级用法：突破性能瓶颈

1. 内存池（Memory Pools）
专用内存池配置：

VmaPoolCreateInfo poolInfo = {};
poolInfo.memoryTypeIndex = ...; // 指定内存类型
poolInfo.blockSize = 64 * 1024 * 1024; // 64MB块
poolInfo.minBlockCount = 1;
poolInfo.maxBlockCount = 8;

VmaPool pool;
vmaCreatePool(allocator, &amp;poolInfo, &amp;pool);

// 在池中分配资源
VmaAllocationCreateInfo poolAllocInfo = {};
poolAllocInfo.pool = pool;  // 指定内存池
poolAllocInfo.usage = VMA_MEMORY_USAGE_AUTO; // 自动选择内存类型
poolAllocInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT; // 指定内存访问模式
vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;poolAllocInfo, &amp;buffer, &amp;allocation, nullptr);


2. 高级分配策略
优先设备本地内存：

allocInfo.usage = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE; //更灵活的策略，如果设备本地内存不足或不适用，会自动选择次优的内存类型


延迟内存分配：

allocInfo.flags |= VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT;

VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT 是 VMA 中一个特殊的内存分配标志，用于创建可能会”丢失”的内存分配。这是一个高级功能，主要用于内存管理优化。

  这种分配可能在内存压力大时被VMA回收
  需要定期检查分配是否还有效
  通常配合 VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT 使用


典型应用场景：

  缓存数据
  非关键资源
  可重新生成的资源


最佳实践：

// 创建可丢失且可导致其他分配丢失的分配
VmaAllocationCreateInfo allocInfo = {};
allocInfo.flags = VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT |
                 VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT;
allocInfo.priority = 0.5f; // 设置优先级

// 定期检查和维护
void maintainResources() {
    for (auto&amp; resource : resources) {
        VmaAllocationInfo allocInfo;
        vmaGetAllocationInfo(allocator, resource.allocation, &amp;allocInfo);
        
        if (allocInfo.deviceMemory == VK_NULL_HANDLE) {
            // 重新创建资源
            recreateResource(resource);
        }
    }
}


3. 内存碎片整理
碎片整理可以显著减少内存碎片，从而腾出连续的大块空间，避免频繁出现 OOM (Out Of Memory，内存耗尽)或内存分配失败的情况。当应用程序长期运行时，频繁的内存分配和释放可能导致内存碎片化，使得即使总的可用内存充足，也无法分配较大的连续内存块。

VMA 提供了一整套接口来执行碎片整理：


  vmaBeginDefragmentation()：初始化碎片整理上下文
  vmaBeginDefragmentationPass() / vmaEndDefragmentationPass()：执行碎片整理的一个或多个 Pass
  vmaEndDefragmentation()：结束碎片整理进程
  vmaDefragment()：单次执行碎片整理


注意：碎片整理期间，某些资源的内存可能会被移动，需要确保资源处于安全状态（通常在 GPU 空闲或可被重新绑定时进行）。

单次碎片整理流程：

VmaDefragmentationInfo defragInfo = {};
defragInfo.flags = VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST;

VmaDefragmentationStats stats;
vmaDefragment(allocator, nullptr, 0, nullptr, &amp;defragInfo, &amp;stats);

printf("Freed %llu bytes, moved %u allocations\n", 
    stats.bytesFreed, stats.allocationsMoved);


更复杂的场景需要使用vmaBeginDefragmentation()和vmaEndDefragmentation()，以及vmaBeginDefragmentationPass()和vmaEndDefragmentationPass()。

4. 稀疏资源管理
稀疏纹理分配示例：
VkImageCreateInfo sparseImageInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
sparseImageInfo.flags = VK_IMAGE_CREATE_SPARSE_BINDING_BIT;
sparseImageInfo.extent = {8192, 8192, 1}; // 8K*8K纹理

VmaAllocationCreateInfo sparseAllocInfo = {};
sparseAllocInfo.flags = VMA_ALLOCATION_CREATE_SPARSE_BINDING_BIT;

vmaCreateImage(allocator, &amp;sparseImageInfo, &amp;sparseAllocInfo, &amp;image, &amp;allocation, nullptr);


5.内存预算管理
内存预算管理主要包含两个关键功能：


  查询预算信息
通过 vmaGetBudget 接口可查询各个显存堆的预算和使用情况：


VmaBudget budgets[VK_MAX_MEMORY_HEAPS];
vmaGetHeapBudgets(allocator, budgets);

// 检查第一个堆的使用情况
printf("Heap 0: Usage %llu MB / Budget %llu MB\n",
    budgets[0].usage &gt;&gt; 20,
    budgets[0].budget &gt;&gt; 20);



  预算控制
使用 VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT 标志可限制内存分配在预算范围内：


VmaAllocationCreateInfo allocInfo = {};
allocInfo.flags = VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT;

// 若超出预算,vmaCreateBuffer 将返回 VK_ERROR_OUT_OF_DEVICE_MEMORY
VkResult result = vmaCreateBuffer(
    allocator, &amp;bufferInfo, &amp;allocInfo,
    &amp;buffer, &amp;allocation, nullptr);


6.虚拟分配器
虚拟分配器的核心思想是在不实际分配物理设备内存的情况下，模拟内存分配的行为。这对于以下场景特别有用：

  内存分配策略的预演和验证
  资源布局的优化
  自定义内存管理系统的实现


例如：

// 模拟不同的资源分配方案
void SimulateResourceLayout() {
    VmaVirtualBlock block;
    vmaCreateVirtualBlock(&amp;VmaVirtualBlockCreateInfo{
        .size = 1024 * 1024 * 64 // 64MB
    }, &amp;block);
    
    struct AllocationRecord {
        VmaVirtualAllocation allocation;
        VkDeviceSize offset;
        VkDeviceSize size;
        const char* resourceName;
    };
    std::vector&lt;AllocationRecord&gt; allocations;
    
    // 模拟分配各种资源
    auto allocateResource = [&amp;](VkDeviceSize size, const char* name) {
        VmaVirtualAllocationCreateInfo allocInfo = {};
        allocInfo.size = size;
        allocInfo.alignment = 256;
        
        AllocationRecord record = {};
        record.size = size;
        record.resourceName = name;
        
        if (vmaVirtualAllocate(block, &amp;allocInfo, &amp;record.allocation, &amp;record.offset) == VK_SUCCESS) {
            allocations.push_back(record);
            return true;
        }
        return false;
    };
    
    // 分配各种资源
    allocateResource(1024 * 1024, "Texture1");
    allocateResource(512 * 1024, "Vertex Buffer");
    allocateResource(256 * 1024, "Index Buffer");
    
    // 分析内存布局
    VmaStatInfo stats;
    vmaCalculateVirtualBlockStats(block, &amp;stats);
    
    // 输出内存使用情况
    for (const auto&amp; record : allocations) {
        printf("Resource: %s, Offset: %llu, Size: %llu\n",
               record.resourceName, record.offset, record.size);
    }
    
    // 清理
    for (const auto&amp; record : allocations) {
        vmaVirtualFree(block, record.allocation);
    }
    vmaDestroyVirtualBlock(block);
}


关键数据结构

  VmaAllocator
    
      VMA 的核心对象
      代表一个全局或应用级别的内存分配器
    
  
  VmaAllocation
    
      代表一次内存分配
      对应底层 Vulkan Device Memory 中的一块区域
    
  
  VmaAllocationCreateInfo
    
      创建分配时的配置结构
      包含 VmaMemoryUsage、映射选项、独立分配等参数
    
  
  VmaAllocationInfo
    
      分配完成后返回的详细信息
      包含偏移量、实际大小、映射指针等数据
    
  
  VmaMemoryUsage
    
      指定内存分配的用途
      如 GPU_ONLY、CPU_ONLY 等类型
    
  
  VmaPool
    
      自定义内存池对象
      用于统一管理多种内存分配
    
  
  VmaPoolCreateInfo
    
      内存池的创建参数
      配置池的属性和行为
    
  
  VmaBudget
    
      内存预算管理结构
      跟踪内存使用量和可用预算
    
  
  VmaStatistics &amp; VmaDetailedStatistics
    
      内存使用统计信息
      提供详细的内存分配状态
    
  
  VmaVirtualAllocation &amp; VmaVirtualBlock
    
      虚拟内存分配相关结构
      用于无物理内存的资源规划
    
  


推荐使用模式
VMA 官方文档中针对常见资源使用模式（如 GPU-only 资源、上传缓冲、回读缓冲、以及高级数据传输模式）都给出了对应的 VmaMemoryUsage 和配置建议。例如：


  GPU-only 资源：
    
      VMA_MEMORY_USAGE_GPU_ONLY
      VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT（可选）
    
  
  CPU -&gt; GPU 上传：
    
      VMA_MEMORY_USAGE_CPU_TO_GPU
      VMA_ALLOCATION_CREATE_MAPPED_BIT（可选）
    
  
  GPU -&gt; CPU 读取：
    
      VMA_MEMORY_USAGE_GPU_TO_CPU
    
  
  先进的上传数据管理：
    
      结合自定义内存池
      使用线性分配算法提升效率
    
  


自动映射
VMA_ALLOCATION_CREATE_MAPPED_BIT 是一个在创建 VMA 内存分配时使用的标志位，它的主要功能是在分配内存的同时自动将其映射到 CPU 可访问的地址空间。这样可以省去手动调用 vmaMapMemory 的步骤。
// 不使用 VMA_ALLOCATION_CREATE_MAPPED_BIT 的传统方式
{
    VmaAllocationCreateInfo allocInfo = {};
    allocInfo.usage = VMA_MEMORY_USAGE_CPU_TO_GPU;
    
    VmaAllocation allocation;
    VkBuffer buffer;
    // 创建buffer和分配内存
    vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, nullptr);
    
    // 需要手动映射内存
    void* mappedData;
    vmaMapMemory(allocator, allocation, &amp;mappedData);
    
    // 使用映射的内存
    memcpy(mappedData, sourceData, dataSize);
    
    // 需要手动解除映射
    vmaUnmapMemory(allocator, allocation);
}

// 使用 VMA_ALLOCATION_CREATE_MAPPED_BIT 的方式
{
    VmaAllocationCreateInfo allocInfo = {};
    allocInfo.usage = VMA_MEMORY_USAGE_CPU_TO_GPU;
    allocInfo.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT; // 自动映射
    
    VmaAllocation allocation;
    VkBuffer buffer;
    VmaAllocationInfo allocInfo;
    
    // 创建buffer和分配内存，同时获取分配信息
    vmaCreateBuffer(allocator, &amp;bufferInfo, &amp;allocInfo, &amp;buffer, &amp;allocation, &amp;allocInfo);
    
    // 直接通过 allocInfo.pMappedData 访问映射的内存
    memcpy(allocInfo.pMappedData, sourceData, dataSize);
    
    // 不需要手动解除映射，会在内存释放时自动处理
}


性能优化实践

通过合理使用VMA的高级特性，在真实项目中可实现：


  内存分配耗时降低70%（对比原生Vulkan接口）
  显存碎片率控制在5%以下
  内存泄漏检测效率提升90%


典型案例：

  《赛博朋克2077》：使用VMA管理超过20GB的显存资源
  Unreal Engine 5：集成VMA实现跨平台内存管理
  DOOM Eternal：通过VMA内存池技术降低8%的显存占用


VMA PDF文档｜Generated by Doxygen

                        </a>
                        <div class="info-post">
                                <a href="/EasyVulkan" class="category">EasyVulkan</a>
                            
                                <span class="date">· 2025-01-26</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/EasyVulkan/Vulkan%E5%88%9D%E5%A7%8B%E5%8C%96.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250124230354.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/EasyVulkan/Vulkan%E5%88%9D%E5%A7%8B%E5%8C%96.html"><h1 class="title_post">Vulkan初始化</h1></a>
                        <a href="/EasyVulkan/Vulkan%E5%88%9D%E5%A7%8B%E5%8C%96.html" class="txt_post">
                            
  最开始接触Vulkan时，通常会被其复杂的概念和庞大的API所吓到。无法理解window、instance、surface等概念的关系，不能区分物理设备和逻辑设备的区别。本文将介绍Vulkan的初始化过程，并解释各个概念之间的关系。最后，本文将介绍EasyVulkan项目的VulkanDevice和VulkanContext对这些概念的封装。


整体流程

  创建 Window
  创建 Instance
    
      检查和启用必要的validation layers（如果在debug模式下）
      设置必要的instance extensions，特别是GLFW要求的extensions
    
  
  创建 Window Surface
  获取物理设备
    
      检查物理设备是否支持所需的features和extensions
      检查物理设备是否适合（比如是否为独立显卡、是否支持所需的图形特性等）
    
  
  获取队列族索引
  创建逻辑设备
    
      创建队列创建信息
      启用必要的device extensions（比如VK_KHR_swapchain）
      指定设备features
    
  
  创建命令池


1.创建Window
使用 GLFW 创建窗口，这是显示 Vulkan 渲染结果的基础：

glfwInit();
glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);  // 不创建 OpenGL 上下文
glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);    // 暂时禁用窗口大小调整

window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr);

由于历史原因，GLFW 最初是为 OpenGL 设计的窗口管理库，默认情况下，当你创建 GLFW 窗口时，它会自动创建一个 OpenGL 上下文。因此需要指定GLFW_CLIENT_API为GLFW_NO_API，只创建窗口，而不创建 OpenGL 上下文。

2.创建 Instance

Instance 是应用程序与 Vulkan 库之间的连接：

VkApplicationInfo appInfo{};
appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
appInfo.pApplicationName = "Vulkan App";
appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
appInfo.pEngineName = "No Engine";
appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
appInfo.apiVersion = VK_API_VERSION_1_0;

VkInstanceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
createInfo.pApplicationInfo = &amp;appInfo;

// 获取 GLFW 需要的 extension
uint32_t glfwExtensionCount = 0;
const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);
createInfo.enabledExtensionCount = glfwExtensionCount;
createInfo.ppEnabledExtensionNames = glfwExtensions;

vkCreateInstance(&amp;createInfo, nullptr, &amp;instance);

Instance 代表了一个 Vulkan 应用程序的实例，它主要负责：


  告诉 Vulkan 驱动程序我们要使用哪些全局扩展（比如与窗口系统的集成）
  告诉驱动程序我们的应用程序信息（名称、版本等）
  设置调试回调
  枚举系统中可用的物理设备（GPU）


Instance的创建过程恰恰说明了他的角色：
VkInstanceCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;

// 告诉 Vulkan 我们的应用程序信息
createInfo.pApplicationInfo = &amp;appInfo;

// 告诉 Vulkan 我们需要哪些扩展
createInfo.enabledExtensionCount = glfwExtensionCount;
createInfo.ppEnabledExtensionNames = glfwExtensions;

// 告诉 Vulkan 我们需要哪些验证层（用于调试）
createInfo.enabledLayerCount = validationLayers.size();
createInfo.ppEnabledLayerNames = validationLayers.data();


可以把 Instance 想象成一个”门户”或”接待员”：
// 没有 Instance 之前，我们无法调用大多数 Vulkan 函数
// 创建 Instance 后，我们可以做这些事：
vkEnumeratePhysicalDevices(instance, ...);  // 查询 GPU
vkCreateDebugUtilsMessengerEXT(instance, ...);  // 设置调试
// 等等


Instance可以被理解为一个“配置中心”，我们可以通过他告诉Vulkan：

  这是我的应用程序
  这是我需要的功能
  这是我的调试需求


3. 创建 Window Surface

Window Surface 提供了 Vulkan 与窗口系统的连接：

VkSurfaceKHR surface;
if (glfwCreateWindowSurface(instance, window, nullptr, &amp;surface) != VK_SUCCESS) {
    throw std::runtime_error("failed to create window surface!");
}

Vulkan 是与平台无关的图形 API，不直接处理窗口系统。Window Surface 是 Vulkan 和窗口系统之间的桥梁,它提供了一个可以渲染到的目标平面.
工作流程

  Vulkan 渲染流程 → Swapchain → Surface → 窗口系统 → 显示到屏幕


// 1. 创建 Surface
VkSurfaceKHR surface;
glfwCreateWindowSurface(instance, window, nullptr, &amp;surface);

// 2. Surface 用于创建 Swapchain
VkSwapchainCreateInfoKHR createInfo{};
createInfo.surface = surface;  // Surface 告诉 Swapchain 渲染目标在哪里

// 3. 渲染时
vkAcquireNextImageKHR(...);    // 从 Swapchain 获取下一个可用的图像
// 渲染到图像
vkQueuePresentKHR(...);        // 通过 Surface 将渲染结果显示到窗口


Surface的作用

  提供图像呈现能力
    
      决定支持的图像格式
      决定支持的呈现模式
    
  
  处理平台差异
    
      Windows：使用 Win32 窗口系统
      Linux：使用 X11 或 Wayland
      macOS：使用 Metal 层
    
  


可以把 Surface 想象成一个”画布”：

  Vulkan 是画家（渲染器）
  Window 是画框（显示窗口）
  Surface 是画布，它把画家的作品（渲染结果）放在画框中展示






图 1：Surface 的作用。



4. 获取物理设备

选择合适的物理设备（显卡）：

uint32_t deviceCount = 0;
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr);
std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());

// 选择第一个适合的设备
VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
for (const auto&amp; device : devices) {
    if (isDeviceSuitable(device)) {
        physicalDevice = device;
        break;
    }
}


isDeviceSuitable 函数通常会检查以下几个关键方面来确定物理设备是否满足应用需求：

  基本设备信息检查
    bool isDeviceSuitable(VkPhysicalDevice device) {
 // 获取设备基本属性
 VkPhysicalDeviceProperties deviceProperties;
 vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    
 // 获取设备特性
 VkPhysicalDeviceFeatures deviceFeatures;
 vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);

 // 检查是否为独立显卡
 bool isDiscreteGPU = deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU;
}
    
  
  队列族支持检查
    bool checkQueueFamilySupport(VkPhysicalDevice device) {
 QueueFamilyIndices indices = findQueueFamilies(device);
    
 // 检查是否支持所需的所有队列族
 // - 图形队列族
 // - 计算队列族
 // - 显示队列族
 return indices.isComplete();
}
    
  
  设备扩展支持检查
    bool checkDeviceExtensionSupport(VkPhysicalDevice device) {
 // 获取设备支持的扩展
 uint32_t extensionCount;
 vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, nullptr);
 std::vector&lt;VkExtensionProperties&gt; availableExtensions(extensionCount);
 vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, availableExtensions.data());

 // 检查必要的扩展是否被支持
 // 比如 VK_KHR_swapchain
 std::set&lt;std::string&gt; requiredExtensions = {
     VK_KHR_SWAPCHAIN_EXTENSION_NAME
 };
    
 for (const auto&amp; extension : availableExtensions) {
     requiredExtensions.erase(extension.extensionName);
 }

 return requiredExtensions.empty();
}
    
  
  Swapchain 适配性检查
    bool checkSwapChainAdequate(VkPhysicalDevice device) {
 // 检查 surface 格式
 uint32_t formatCount;
 vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, nullptr);
    
 // 检查显示模式
 uint32_t presentModeCount;
 vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, nullptr);
    
 return formatCount &gt; 0 &amp;&amp; presentModeCount &gt; 0;
}
    
  
  内存属性检查
    bool checkMemoryProperties(VkPhysicalDevice device) {
 VkPhysicalDeviceMemoryProperties memProperties;
 vkGetPhysicalDeviceMemoryProperties(device, &amp;memProperties);
    
 // 检查是否有足够的显存
 // 检查是否支持所需的内存类型
 return true; // 根据具体需求判断
}
    
  
  综合评分系统（可选）
    int rateDeviceSuitability(VkPhysicalDevice device) {
 int score = 0;
    
 // 基础分：独立显卡加分
 VkPhysicalDeviceProperties deviceProperties;
 vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    
 if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
     score += 1000;
 }
    
 // 性能分：根据最大纹理大小加分
 score += deviceProperties.limits.maxImageDimension2D;
    
 // 特性分：支持几何着色器加分
 VkPhysicalDeviceFeatures deviceFeatures;
 vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);
 if (deviceFeatures.geometryShader) {
     score += 100;
 }
    
 return score;
}
    
  


最终的设备选择函数如下：
bool isDeviceSuitable(VkPhysicalDevice device) {
    bool extensionsSupported = checkDeviceExtensionSupport(device);
    bool swapChainAdequate = false;
    
    if (extensionsSupported) {
        swapChainAdequate = checkSwapChainAdequate(device);
    }
    
    return checkQueueFamilySupport(device) &amp;&amp; 
           extensionsSupported &amp;&amp; 
           swapChainAdequate &amp;&amp;
           checkMemoryProperties(device) &amp;&amp;
           rateDeviceSuitability(device) &gt; minRequiredScore;
}

5. 获取队列族索引

查找支持所需操作的队列族：

struct QueueFamilyIndices {
    std::optional&lt;uint32_t&gt; graphicsAndComputeFamily; // 图形和计算共用一个队列族
    std::optional&lt;uint32_t&gt; presentFamily;
    
    bool isComplete() {
        return graphicsAndComputeFamily.has_value() &amp;&amp; presentFamily.has_value();
    }
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    uint32_t queueFamilyCount = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);
    std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());
    
    // 查找支持图形和计算的队列族
    // 查找支持显示的队列族
    // ... 具体实现略
    
    return indices;
}

队列族
队列族是一组具有相同功能的队列（Queue），可以理解为是物理设备的一部分，每个队列族支持特定类型的操作，比如：


  图形操作（绘制命令）
  计算操作（计算着色器）
  传输操作（内存复制）
  显示操作（显示到屏幕）


物理设备（GPU）
├── 队列族 0（支持图形+计算+传输）
│   ├── 队列 0
│   └── 队列 1
├── 队列族 1（仅支持传输）
│   └── 队列 0
└── 队列族 2（支持显示）
    └── 队列 0


可以查询每个队列族的队列数量、支持的特性，比如：

// 获取队列族属性
uint32_t queueFamilyCount = 0;
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &amp;queueFamilyCount, nullptr);
std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, &amp;queueFamilyCount, queueFamilies.data());
// 遍历每个队列族，查看其中的队列数量
for (uint32_t i = 0; i &lt; queueFamilyCount; i++) {
    const auto&amp; queueFamily = queueFamilies[i];
    
    // queueCount 就是该队列族中的队列数量
    uint32_t numQueues = queueFamily.queueCount;
    
    // 打印队列族信息
    std::cout &lt;&lt; "Queue Family " &lt;&lt; i &lt;&lt; ":\n";
    std::cout &lt;&lt; "  Number of queues: " &lt;&lt; numQueues &lt;&lt; "\n";
    std::cout &lt;&lt; "  Supports graphics: " &lt;&lt; (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT ? "yes" : "no") &lt;&lt; "\n";
    std::cout &lt;&lt; "  Supports compute: " &lt;&lt; (queueFamily.queueFlags &amp; VK_QUEUE_COMPUTE_BIT ? "yes" : "no") &lt;&lt; "\n";
    std::cout &lt;&lt; "  Supports transfer: " &lt;&lt; (queueFamily.queueFlags &amp; VK_QUEUE_TRANSFER_BIT ? "yes" : "no") &lt;&lt; "\n";
}


队列族作用
在创建逻辑设备时需要制定使用的队列族，比如：
// 创建队列信息
float queuePriority = 1.0f;
VkDeviceQueueCreateInfo queueCreateInfo{};
queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
queueCreateInfo.queueFamilyIndex = graphicsFamily;  // 指定队列族索引
queueCreateInfo.queueCount = 1;                     // 使用的队列数量
queueCreateInfo.pQueuePriorities = &amp;queuePriority;  // 队列优先级


不同队列族

  不同队列族的命令可以并行执行
  专用队列族（如只支持传输的队列族）通常性能更好
  需要在不同队列族之间同步操作时会有性能开销


相同队列族的不同队列
可以使用同一个队列族的两个队列提交命令：
// 获取同一队列族的两个队列
VkQueue queue1, queue2;
vkGetDeviceQueue(device, graphicsFamilyIndex, 0, &amp;queue1);
vkGetDeviceQueue(device, graphicsFamilyIndex, 1, &amp;queue2);

// 这两个队列可以并行执行命令
vkQueueSubmit(queue1, 1, &amp;submitInfo1, fence1);  // 在队列1提交命令
vkQueueSubmit(queue2, 1, &amp;submitInfo2, fence2);  // 在队列2提交命令

// 这两个提交会并行执行，不需要等待队列1完成



  同一队列族的所有队列具有相同的能力（比如都支持图形操作）
  每个队列都有自己独立的命令流
  每个队列都可以独立提交命令缓冲区
  队列之间的执行是异步的(并行执行，没有先后顺序），除非使用同步原语（使用同步原语，可以实现队列2等待队列1完成）


队列优先级和同步
// 创建队列时可以指定不同的优先级
float priorities[] = { 1.0f, 0.5f };  // 两个队列，不同优先级
VkDeviceQueueCreateInfo queueCreateInfo{};
queueCreateInfo.queueCount = 2;
queueCreateInfo.pQueuePriorities = priorities;

// 如果需要队列间同步，可以使用信号量
VkSubmitInfo submitInfo{};
submitInfo.waitSemaphoreCount = 1;
submitInfo.pWaitSemaphores = &amp;waitSemaphore;    // 等待其他队列的信号量
submitInfo.signalSemaphoreCount = 1;
submitInfo.pSignalSemaphores = &amp;signalSemaphore; // 发出完成信号


并行渲染举例
// 场景1：并行渲染多个对象
void renderScene() {
    // 队列1渲染地形
    vkQueueSubmit(queue1, 1, &amp;terrainSubmitInfo, terrainFence);
    
    // 同时，队列2渲染角色
    vkQueueSubmit(queue2, 1, &amp;characterSubmitInfo, characterFence);
    
    // 两个渲染任务并行执行
}

// 场景2：一个队列处理主要渲染，另一个处理后期效果
void render() {
    // 队列1执行主要渲染
    vkQueueSubmit(queue1, 1, &amp;mainRenderSubmitInfo, mainRenderFence);
    
    // 设置依赖关系
    waitSemaphores = mainRenderComplete;
    
    // 队列2执行后期处理
    vkQueueSubmit(queue2, 1, &amp;postProcessSubmitInfo, postProcessFence);
}


6. 创建逻辑设备
创建队列创建信息
如前文所说，逻辑设备的创建需要指定使用的队列族。为每个唯一的队列族创建创建信息结构体：

std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;
std::set&lt;uint32_t&gt; uniqueQueueFamilies = {
    indices.graphicsAndComputeFamily.value(),
    indices.presentFamily.value()
};

float queuePriority = 1.0f;
for (uint32_t queueFamily : uniqueQueueFamilies) {
    VkDeviceQueueCreateInfo queueCreateInfo{};
    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    queueCreateInfo.queueFamilyIndex = queueFamily;   // 指定队列族索引
    queueCreateInfo.queueCount = 1;                    // 使用的队列数量
    queueCreateInfo.pQueuePriorities = &amp;queuePriority;  // 队列优先级
    queueCreateInfos.push_back(queueCreateInfo);
}

创建逻辑设备
VkDeviceCreateInfo deviceCreateInfo{};
deviceCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
deviceCreateInfo.queueCreateInfoCount = static_cast&lt;uint32_t&gt;(queueCreateInfos.size());
deviceCreateInfo.pQueueCreateInfos = queueCreateInfos.data();  // 指定队列创建信息

VkPhysicalDeviceFeatures deviceFeatures{};
deviceCreateInfo.pEnabledFeatures = &amp;deviceFeatures;  // 指定设备特性

VkDevice device;
if (vkCreateDevice(physicalDevice, &amp;deviceCreateInfo, nullptr, &amp;device) != VK_SUCCESS) {
    throw std::runtime_error("failed to create logical device!");
}


如前面提到的，队列族是物理设备的一部分，逻辑设备创建时需要指定使用的队列族和队列的数量，因此可以将逻辑设备理解为建立在队列族上对物理设备的抽象。
即：
物理设备（GPU）
    └── 逻辑设备（对GPU的抽象接口）
            ├── 队列族 0
            │   ├── 队列 0
            │   └── 队列 1
            └── 队列族 1
                └── 队列 0

上面展示了如何指定队列族和队列数量来创建逻辑设备，下面展示如何从逻辑设备获取队列：
// 从逻辑设备获取队列
VkQueue graphicsQueue;
vkGetDeviceQueue(logicalDevice,  // 逻辑设备句柄
                 graphicsFamilyIndex,  // 队列族索引
                 0,  // 队列索引
                 &amp;graphicsQueue);  // 获取到的队列


逻辑设备的功能

  创建和管理各种 Vulkan 资源（缓冲区、图像等）
  提供队列访问接口
  启用设备特性和扩展
  控制设备内存分配
例如：


// 使用逻辑设备创建资源
VkBuffer buffer;
vkCreateBuffer(logicalDevice, &amp;bufferInfo, nullptr, &amp;buffer);
// 使用逻辑设备分配内存
VkDeviceMemory memory;
vkAllocateMemory(logicalDevice, &amp;allocInfo, nullptr, &amp;memory);


不同的逻辑设备

  一个应用程序可以创建多个逻辑设备
  每个逻辑设备都有自己的队列和资源
  不同逻辑设备间的资源不能直接共享
  逻辑设备销毁时，其创建的所有资源也会被销毁


7. 创建命令池

创建用于管理命令缓冲区的命令池：

VkCommandPoolCreateInfo poolInfo{};
poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
poolInfo.queueFamilyIndex = indices.graphicsAndComputeFamily.value();  // 指定队列族索引
poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT; // 允许单独重置命令缓冲区

VkCommandPool commandPool;
if (vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;commandPool) != VK_SUCCESS) {
    throw std::runtime_error("failed to create command pool!");
}

命令池的作用

  命令池用于管理命令缓冲区的内存
  每个命令池只能分配给特定的队列族使用
  从同一个命令池分配的命令缓冲区只能提交到同一队列族的队列中(因为第二点指定了队列族的类型)


命令池标志
// 常用的命令池标志
VK_COMMAND_POOL_CREATE_TRANSIENT_BIT  // 提示命令缓冲区会频繁重录制，可以优化内存分配
VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT  // 允许单独重置命令缓冲区，而不是只能重置整个池
VK_COMMAND_POOL_CREATE_PROTECTED_BIT  // 创建受保护的命令缓冲区


分配命令缓冲
VkCommandBufferAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
allocInfo.commandPool = commandPool;  // 指定命令池
allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;  // 主要或次要命令缓冲区
allocInfo.commandBufferCount = 1;  // 分配数量

VkCommandBuffer commandBuffer;
vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);


命令池（Command Pool）和命令缓冲区（Command Buffer）

  命令池是内存池
  命令缓冲区是从这个内存池分配的内存块
  所有命令缓冲区共享命令池的属性（如队列族绑定）
  命令池管理着所有命令缓冲区的生命周期
    内存管理关系
  


// 命令池负责管理命令缓冲区的内存分配
VkCommandPool commandPool;
std::vector&lt;VkCommandBuffer&gt; commandBuffers;

// 从命令池分配命令缓冲区
VkCommandBufferAllocateInfo allocInfo{};
allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
allocInfo.commandPool = commandPool;              // 指定从哪个命令池分配
allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
allocInfo.commandBufferCount = 1;                 // 分配数量

vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);


生命周期关系

  命令池控制着其分配的所有命令缓冲区的生命周期
  销毁命令池时会自动销毁其分配的所有命令缓冲区
    void cleanup() {
  // 不需要单独释放命令缓冲区
  vkDestroyCommandPool(device, commandPool, nullptr); // 会自动释放所有命令缓冲区
}

    重置关系
  


// 重置整个命令池（影响所有命令缓冲区）
vkResetCommandPool(device, commandPool, VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT);

// 如果命令池创建时指定了 VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT
// 则可以单独重置命令缓冲区
vkResetCommandBuffer(commandBuffer, VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT);


队列族关系

// 命令池绑定到特定队列族
VkCommandPoolCreateInfo poolInfo{};
poolInfo.queueFamilyIndex = graphicsQueueFamily;  // 指定队列族

// 从该命令池分配的命令缓冲区只能提交到同一队列族的队列
VkSubmitInfo submitInfo{};
submitInfo.commandBufferCount = 1;
submitInfo.pCommandBuffers = &amp;commandBuffer;
vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, fence);  // 队列必须属于同一队列族


实例扩展和设备扩展
实例扩展（Instance Extensions）：
作用范围：作用于整个 Vulkan 实例（VkInstance），影响全局功能
主要用途：

  提供跨平台功能，如窗口系统集成（WSI）
  添加调试和验证层支持
  提供实例级别的新功能


加载时机：在创建 VkInstance 时通过 vkCreateInstance 启用

常见的实例扩展：
VK_KHR_surface

  最基础的窗口系统接口扩展
  定义了创建和管理平台无关的窗口表面的基础功能
  几乎所有需要显示的应用都会用到


平台特定的 surface 扩展：

  VK_KHR_win32_surface (Windows)
  VK_KHR_xlib_surface (X11/Linux)
  VK_KHR_wayland_surface (Wayland/Linux)
  VK_KHR_android_surface (Android)
  VK_MVK_macos_surface (macOS)


VK_EXT_debug_utils

  提供调试功能
  允许为 Vulkan 对象添加标签和名称
  支持调试信息的回调


VK_KHR_get_physical_device_properties2

  获取物理设备的额外属性信息
  常用于查询新功能的支持情况
    设备扩展（Device Extensions）：
    作用范围：作用于特定的物理设备（VkPhysicalDevice）和逻辑设备（VkDevice）
主要用途：
    
      提供特定硬件功能支持
      启用设备特定的渲染特性
      添加新的设备级API功能
    
  


加载时机：在创建 VkDevice 时通过 vkCreateDevice 启用

常见的设备扩展：
VK_KHR_swapchain

  最基础的显示相关扩展
  用于创建和管理交换链
  实现帧缓冲和显示同步


VK_KHR_maintenance1/2/3

  提供各种 API 改进和补充功能
  修复早期版本的一些限制和问题


VK_KHR_dynamic_rendering

  简化渲染流程
  无需创建 render pass 对象
  更灵活的渲染配置


VK_KHR_multiview

  支持单次渲染传递到多个视图
  用于 VR 等立体渲染场景


VK_KHR_shader_*系列：
VK_KHR_shader_float16_int8  // 支持16位浮点和8位整数
VK_KHR_shader_non_semantic_info  // 着色器附加信息
VK_KHR_shader_draw_parameters  // 绘制参数访问


EasyVulkan的初始化设计
在EasyVulkan中，初始化主要由VulkanContext和VulkanDevice两个类完成。

VulkanContext
主要用于管理各种Vulkan的对象和资源。

  创建 Vulkan 实例，可选择设置验证层和调试回调。
  拥有对 VulkanDevice、SwapchainManager、ResourceManager、CommandPoolManager 和可选的 SynchronizationManager 的引用。
  协调高级生命周期（初始化、清理）。


VulkanDevice
VulkanDevice类主要对物理设备和逻辑设备进行管理。

  选择具有所需功能的物理设备，创建逻辑设备。
  维护队列句柄（图形、计算、传输）。
  集成 Vulkan 内存分配器（VMA）。


使用说明
借助VulkanDevice本身就是VulkanContext的成员，因此初始化可以简化为：
VulkanContext context;
context.initialize();

在VulkanContext中，我们可以借助Manager类来管理各种Vulkan的对象和资源。
例如，使用SwapchainManager：

  创建和管理交换链
  处理窗口调整事件
  管理交换链图像和图像视图
  提供图像获取和呈现功能


使用ResourceManager：

  所有主要 Vulkan 资源的生成器接口（如BufferBuilder、ImageBuilder、ShaderModuleBuilder等）
  自动资源跟踪和清理
  基于名称的资源查找


                        </a>
                        <div class="info-post">
                                <a href="/EasyVulkan" class="category">EasyVulkan</a>
                            
                                <span class="date">· 2025-01-24</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E9%99%8D%E9%87%87%E6%A0%B7.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250112201138.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E9%99%8D%E9%87%87%E6%A0%B7.html"><h1 class="title_post">图像降采样</h1></a>
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E9%99%8D%E9%87%87%E6%A0%B7.html" class="txt_post">
                            
  最近的一个横向中涉及对图像进行降采样的问题，最近两周实现和对比了一些降采样的方法，在本文中进行归纳总结。
本文的主要内容包括：1.介绍几种常见的降采样方法。2.对比不同方法的性能。3.基于计算着色器实现区域平均。


定义
图像降采样(Image Downsampling)是指通过减少图像的像素数量来降低图像分辨率的过程。具体来说，它是将高分辨率的原始图像转换为较低分辨率的图像，同时尽可能保持图像的视觉质量和关键信息。

    
    图 1：区域均值降采样。


常见的图像降采样方法包括：

  最近邻插值  选择最接近的像素值
  双线性插值  使用周围4个像素的加权平均
  双三次插值  使用周围16个像素的加权平均
  区域平均  计算采样区域内所有像素的平均值


问题目标

  将图像的分辨率降低到 $\frac{W}{2^n} \times \frac{H}{2^n}$。
  在保证图片质量的前提下，尽可能提高计算速度。
  使用C++、OpenGL或Vulkan实现。


下采样方法
为了平衡计算速度和图片质量，本文主要研究双线性插值或区域平均。
双线性插值
图形API中的双线性插值
在OpenGL或Vulkan等图形API中，双线性插值被广泛的支持，例如在OpenGL中，可以使用glTexImage2D函数来创建一个纹理，并指定GL_LINEAR作为纹理过滤器，从而在片段着色器中使用双线性插值对该纹理进行采样。除了GL_LINEAR外，还包括：

  GL_NEAREST：最近邻插值
  GL_NEAREST_MIPMAP_LINEAR：根据bias参数选择两个mipmap层，mipmap层内部进行最近邻插值，mipmap层之间使用线性插值。
  
    GL_NEAREST_MIPMAP_NEAREST：选择最近的mipmap层，在单个mipmap中最近邻插值。
  
  GL_LINEAR_MIPMAP_NEAREST：选择最近的mipmap层，在单个mipmap中双线性插值。
  GL_LINEAR_MIPMAP_LINEAR：根据bias参数选择两个mipmap层，mipmap层内部进行双线性插值，mipmap层之间使用线性插值。


在Vulkan中，将图像绑定到描述符集时，可以为该图像创建采样器，可以为采样器指定类似于前文OpenGL提供的采样参数,具体包括：

  VK_FILTER_NEAREST：最近邻插值
  VK_FILTER_LINEAR：双线性插值


如果开启mipmap，则可以指定：

  VK_SAMPLER_MIPMAP_MODE_NEAREST：对mipmap进行最近邻插值
  VK_SAMPLER_MIPMAP_MODE_LINEAR：对mipmap进行双线性插值


双线性插值理论

    
    图 2：双线性插值。


双线性插值需要使用最近的四个像素进行插值，计算公式如下：
\(I(x, y) = (1 - dx) * (1 - dy) * I(0, 0) + dx * (1 - dy) * I(1, 0) + (1 - dx) * dy * I(0, 1) + dx * dy * I(1, 1)\)
其中，$I(x, y)$是插值后的像素值，$I(0, 0)$、$I(1, 0)$、$I(0, 1)$、$I(1, 1)$是最近的四个像素值，$dx$和$dy$是插值点相对于最近四个像素点的偏移量。

将双线性插值应用于降采样时，如果将分辨率降低为原始分辨率的$\frac{1}{2}$，那么等价于对四个像素进行区域平均，即：
\(I(0.5,0.5) = (1-0.5) * (1-0.5) * I(0, 0) + 0.5 * (1-0.5) * I(1, 0) + (1-0.5) * 0.5 * I(0, 1) + 0.5 * 0.5 * I(1, 1) \\
I(0.5,0.5) = \frac{I(0, 0) + I(1, 0) + I(0, 1) + I(1, 1)}{4} \phantom{* (1-0.5) * I(0, 0) + 0.5 * (1-0.5) * I(1, 0) + (1-0.5) * 0.5 * I(0, 1) + 0.5 * 0.5 * I(1, 1)}\)

    
    图 3：图像分辨率降低一半时，双线性插值等价于区域平均。


然而，当降采样比率较大时($\frac{width_{original}}{width_{downsampled}} &gt; 2$)，双线性插值会”遗漏”一些像素，从而带来图像质量的显著损失。如下图所示，蓝色的像素是原始图像中的像素，深色的像素是降采样后对应回原图的区域，橙色圆形是该区域的中心，对橙色圆形进行双线性插值时参与的只有蓝色圆形所示的点，其他像素被”遗漏”。

    
    图 4：降采样样比率较大时，双线性插值会"遗漏"一些像素。


因此，为了保证降采样图像的质量，逐级降采样是更好的选择。所谓逐级降采样，是指将图像先降采样到$\frac{1}{2}$，再降采样到$\frac{1}{4}$，再降采样到$\frac{1}{8}$，以此类推。

    
    图 5：逐级降采样。


这种逐级降采样的方式非常适合在图形管线中实现。在OpenGL中，我们可以通过两种方式来实现:

  使用glGenerateMipmap函数自动生成mipmap序列，这是最简单直接的方法
  将原始图像作为输入纹理，通过多次渲染并利用双线性插值采样到更小的目标图像上，逐步完成降采样过程


与OpenGL不同，Vulkan没有提供类似glGenerateMipmap的便捷函数。在Vulkan中，我们需要通过重复调用vkCmdBlitImage命令来手动生成每一级mipmap。虽然这种方式需要更多的代码，但也给了开发者更大的灵活性和控制权。
下文将对比这三种方式的时间和优缺点。

区域平均理论
区域平均是一种简单直观且计算高效的图像降采样方法。它通过以下步骤实现图像的降采样处理：


  根据目标图像尺寸，将原始图像划分为多个大小相等、互不重叠的矩形区域
  对每个矩形区域内的所有像素值进行算术平均计算
  将计算得到的平均值赋给降采样后图像中对应位置的像素


这种方法的一大优势在于其灵活性： 它可以通过单次计算过程将图像直接降采样到任意目标尺寸，而不需要多次迭代。这种特性使其在某些场景下具有明显的性能优势。
实现和对比
glGenerateMipmap
直接调用函数即可。

逐级降采样
思路：输入纹理A，将纹理B作为帧缓冲的颜色附件，纹理B的分辨率是纹理A的$\frac{1}{2}$。
准备阶段：
width, height
For mipmapLevel = 0 to mipmapLevelMax:
    Create Texture[mipmapLevel] with width ,height
    Create Framebuffer[mipmapLevel] with Texture[mipmapLevel]
    width, height = width / 2, height / 2


渲染阶段：
For mipmapLevel = 0 to mipmapLevelMax:
    Bind Framebuffer[mipmapLevel]
    Bind Texture[mipmapLevel-1]
    Render


Vulkan Mipmap生成
重复调用vkCmdBlitImage命令，将mipmapLevel-1的图像blit到mipmapLevel。

时间统计方法
CPU时间
CPU时间是指CPU侧执行代码的时间(包含CPU侧的处理，指令提交到GPU，GPU执行，GPU返回结果的时间)，即资源分配和GPU执行的时间。
1.使用std::chrono::high_resolution_clock::now()和std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count()来统计时间。
2.使用Nvidia Nsight Compute来统计CPU时间。
GPU时间
GPU时间是指GPU执行该指令提交到GPU的任务的时间。
1.使用Querypool。
2.使用Nvidia Nsight Compute的GPU Trace Profiler来统计GPU时间。

结果
输入2048*2048的图像。
第一帧：


  
    
      方法
      CPU时间(ms)
      GPU时间(ms)
    
  
  
    
      glGenerateMipmap
      10.8
      2.2
    
    
      逐级降采样
      9.8
      1.4
    
    
      Vulkan Mipmap
      1.9
      1.5
    
  



  注：
  
    逐级降采样中，CPU时间是指创建帧缓冲和纹理的时间。
    VUlkan Mipmap生成的CPU时间只包含blit指令产生的CPU时间(统计该Command提交到返回到时间)，不包含纹理图像创建的时间(VUlkan在创建纹理图像时需要指定Mipmap level，并为之分配内存)。
  


    
    图 6：Vulkan降采样指令返回时间。


第二帧：


  
    
      方法
      CPU时间(ms)
      GPU时间(ms)
    
  
  
    
      glGenerateMipmap
      2.4
      2.1
    
    
      逐级降采样
      9.3
      1.5
    
    
      Vulkan Mipmap
      1.8
      1.5
    
  


从上述结果中可以看出，第一次调用glGenerateMipmap时，CPU时间较长，而Vulkan Mipmap的CPU时间较短，这可能是因为glGenerateMipmap在第一次调用时需要进行一些初始化工作，而Vulkan Mipmap在第一次调用时已经完成了纹理图像的创建。
就GPU侧的速度而言，逐级降采样和Vulkan Mipmap的速度相近，二者都快于glGenerateMipmap。
glGenerateMipmap函数对我们而言就像是一个黑盒子，第二帧的时间显著减少，是否意味着glGenerateMipmap函数在第二次调用时实际没有执行任何操作？为了解答该问题，我使用Nsight Compute的GPU Trace Profiler来查看glGenerateMipmap执行时GPU的占用情况。

    
    图 7：第二帧时glGenerateMipmap执行时GPU的占用情况。



    
    图 8：第二帧时不调用glGenerateMipmap时GPU的占用情况。


从图中可以看出，glGenerateMipmap执行时和不调用该函数相比，GPU的占用率明显更高，因此第二帧时glGenerateMipmap的调用时只有CPU侧的部分资源分配任务被跳过，GPU侧的任务没有明显变化。

区域平均
上述借助双线性插值的方法本质上都是一个“逐级”的过程，这其中驱动层面上会产生额外的开销。并且，数据在GPU的主存和片上内存之间来回传输，存在IO开销。

区域平均则是一个“单次”的过程，它通过一次计算过程将图像直接降采样到任意目标尺寸，而不需要多次迭代。

然而，区域平均无法像双线性插值利用硬件特性，需要我们自己实现。

一种最直接的方法是在片段着色器中读取NxN的像素，然后计算平均值。然而，数据的读取和累加操作是在单个片段着色器中顺序执行的，计算效率低下。


    
    图 9：区域平均的计算过程。


使用Compute Shader
为了提高利用并行性，我们可以使用Compute Shader来进行区域平均。
算法实现：
1.每个线程读取32个像素。
2.在线程内部计算列方向上的求和，根据降采样比率决定累加的数据数量。
3.将中间结果写入恭喜那个内存中。
4.LandID&lt;output_size*output_size的像素读取m个共享内存中的数据。
5.计算行方向上的累加并写入输出图像中。

每个warp中包含32个线程，因此一个Warp处理32*32的区域，如下图所示：


    
    图 10：Warp处理32*32的区域，每个线程读取32个数据。


为了简化过程，我们以4*4的区域为例（假设一个warp中只包含4个线程，每个线程读取4个数据），进行讲解。下采样比率为2，即输出图像的分辨率为输入图像的$\frac{1}{2}$ 。

读取数据
线程根据所在的workgroupID，WarpID，以及线程ID，计算出该线程需要读取的像素的坐标，然后读取这些像素的值到寄存器中。

计算列方向上的求和
列方向上的输出维度为2，因此每$\frac{4}{2}$个像素进行一次累加。

写入共享内存
将中间结果写入共享内存中。

读取共享内存
LandID&lt;2*2的线程读取共享内存中的结果到寄存器。

计算行方向上的累加
计算行方向上的累加并写入输出图像中。

累加过程如图所示：

    
    图 11：累加流程。


实验结果
输入2048*2048的图像，降采样到64*64。


  
    
      方法
      CPU时间(ms)
      GPU时间(ms)
    
  
  
    
      glGenerateMipmap
      2.4
      2.1
    
    
      逐级降采样
      9.3
      1.5
    
    
      Vulkan Mipmap
      1.8
      1.5
    
    
      区域平均(CS)
      0.9
      0.9
    
  


                        </a>
                        <div class="info-post">
                                <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0" class="category">技术学习</a>
                            
                                <span class="date">· 2025-01-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/integral%20Image%E8%AE%A1%E7%AE%97.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250102174554.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/integral%20Image%E8%AE%A1%E7%AE%97.html"><h1 class="title_post">How to compute integral image on GPU?</h1></a>
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/integral%20Image%E8%AE%A1%E7%AE%97.html" class="txt_post">
                            Related Work

GPU Gems 3 (2005). Chapter: “Summed-Area Tables on the GPU” by Dave Johnson (NVIDIA).
https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps

Parallel Prefix Sums
https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda
Scan primitives for GPU computing

GPU-efficient recursive filtering and summed-area tables
https://dl.acm.org/doi/10.1145/2070781.2024210

技术重点：
并行前缀和（Scan）：大多数GPU实现将积分图像计算分解为两个主要的并行前缀和传递，一个是水平方向的，另一个是垂直方向的。
内存合并与冲突：高效的GPU积分图像算法注意内存布局，确保线程访问连续的内存段以减少延迟并提高吞吐量。
工作负载划分（Tile）：大型图像被划分为独立且并行计算的小块。在每个小块上计算出部分总和后，额外进行一次合并操作以得到全局积分图像。
层次化方法：层次化求和策略通过将求和问题拆解成多个阶段来降低处理大型图像时所需处理复杂度。
使用共享内存与寄存器：高性能实现将中间总和保存在在快速GPU共享内存中，从而减少全局内存流量。

Summed-Area Variance Shadow Maps(GPU gem3)
https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps
该章节指出SAT的计算本质上是两个维度的前缀和过程。Hensley et al. 2005.提出了一种更并行的方法。
本章节主要关注积分图像计算时的精度问题，Hensley et al. 2005有很多关于精度问题的解决方案， Donnelly and Lauritzen 2006也给出了一种解决方案。

Parallel Prefix Sum (Scan) with CUDA（GPU Gem3）
Naive Method
CPU的前缀和计算的复杂度为O(n),GPU算法的复杂度如果不超过该复杂度，我们称之为efficient work。

最原始的GPU版本就是一个不高效的实现，该算法需要两个Buffer来保证正确性。同时，该算法还假设处理器单元的数量和数组大小一致。

Work-Efficient Method

  使用平衡树来优化复杂度。
  分成两个过程，Red1uce(归约过程，也被称作上扫过程)；和下扫过程。
  同一个位置上的操作在共享内存中完成。


Reduce



该过程结束后，根结点上保存了整个数组的和。

down-sweep

在上扫描阶段，我们已经获得了总和，但前缀和还未完全计算出来。下扫描阶段通过逆向操作，逐步填充前缀和数组。

上扫描结束后，位置0，1，3，7的值是前缀和数组中会出现的值（为inclusive的，但通常需要计算exclusive的）。例如，25的右子树14需要11的值来更新子节点。
因此，下扫描过程可以理解为一个传递到左子树、累加右子树的过程。

  初始化：设置根节点为0.
  遍历步长数组[4,2,1]
    
      设置左子树为根节点的值，右子树为左子树和右子树的和（左子树使用设置后的值）。
 
 该过程一个线程操作两个元素，需要在同一个work group中完成。
 使用上扫阶段的结果：
        
          树结构：
               25
 /    \
   11      14
  /  \    /  \
 4    7  5    9
/ \  / \ / \  / \
  3  1 7  0 4 1 6 3
            
          
        
      
    
  



  初始化根节点为 0：
            0
      /    \
    11      14
   /  \    /  \
  4    7  5    9
 / \  / \ / \  / \
3  1 7  0 4 1 6 3
    
  
  传递并更新：
    
      根节点 0 分配给左子树 left = 0 和右子树 right = 11（左子树的部分和）。
      左子树 11 分配给其左子树 left = 0 和右子树 right = 4。
      右子树 14 分配给其左子树 left = 11 和右子树 right = 5。
      继续递归，最终得到前缀和数组。
    
  


最终前缀和数组 S = [0, 3, 4, 11, 11, 15, 16, 22]。

Fast Summed‐Area Table Generation and its Applications[Hensley et al. 2005]
提到论文：Simple Blurry Reflections with Environment Maps 似乎是使用miomap近似模糊的lerp blur。
方法
使用图形管线实现，整个过程分解为两个phase，每个phase包括log(n)个pass。
使用两张纹理图像，互相作为输入输出。

积分图像的精度问题

  累加时机器误差的积累。
  使用积分图像时通常是两个接近的值相减，尤其是两个值很大时，误差会更加明显。
  积分图像的最大值大小为$w \times h \times 255$




Using Signed-Offset Pixel Representation
将像素值进行偏移，从[0,1]偏移到[-0.5,0.5],这样可以使得：

  数值不总是单调的。
有两种方式实现这一点：
  所有像素值-0.5.
  所有像素值-平均值。


Using Origin-Centered Image Representation
以图片的中心点作为原点，相当于计算四张更小的积分图像，从而避免了极大值的出现。
但是使用时增加了额外的计算量。

Scan Primitives for GPU Computing 2007
GPU并行模型
符合流水线结构的算法天然适合GPU实现。即，每个kernel处理单独的输入，产生单独的输出。
某些问题，例如前缀求和问题，需要输入数据的全局知识。
相关工作
原始方法
horn 2005
[[#Fast Summed‐Area Table Generation and its Applications[Hensley et al. 2005]]]
这些方法的复杂度为O(nlogn)，是non-work-efficient的。

reduce and down-sweep
提出：Blelloch in 1990[Vector Models for Data-Parallel Computing]
GPU实现：Sengupta(本文作者) et al. and Greß et al. in 2006
CUDA实现：本文

方法
本文方法的主要贡献是引入了分段扫描的概念.
分段扫描Segmented Scan，是一种将输入序列分成多个互不影响的字序列并进行后续操作的过程。
使用flag数组标记不同的分段，例如：
Data: [a, b, c, d, e] 
Flags: [1, 0, 1, 0, 0]


该算法用于解决输入向量超过线程块大小的情况。
在归约过程和下扫描之间插入部分和的计算。
（影响下扫描的初始化）



Efficient Integral Image Computation on the GPU 2010
使用work-efficient的前缀和计算，利用了分段扫描解决大数组问题。积分图像的计算转化为：前缀和-转置-前缀和过程。
使用tanspose操作的优点在于，可以使用同一个kernel完成两次扫描操作。


GPU-Efficient Recursive Filtering and Summed-Area Tables 2011

Efficient Algorithms for the Summed Area Tables  Primitive on GPUs 2018
Related work

Scan-scan algorithms:

  Compute prefix sums directly
  Limited by memory access patterns


Scan-transpose-scan algorithms:

  Use matrix transposition between steps
  Rely heavily on scratchpad memory
  Have expensive matrix transpose operations
  Face memory bandwidth limitations
该方法来自于Efficient Integral Image Computation on the GPU。本文指出，该方法需要对global memory的聚合访问和昂贵的transpose操作。
    
      [!聚合访问]
对全局内容的访问较慢，只有每一个线程以相同stride的方式访问全局内存，才能实现峰值吞吐：
Thread 0: accesses address N 
Thread 1: accesses address N+1 
Thread 2: accesses address N+2 
…and so on
    
  



  [!bank conflict]
现代GPU的共享内容被分成一系列的bank。当同一个warp中的不同线程访问同一个bank时，会发生冲突。
例如，一个warp中存在12个线程，每个线程都需要访问共享内存对应行的32个数据，即第i个线程访问sharedMem[i][0…31]由于bank的存在，每个线程访问数据j时都对应到同一个bank中，因此存在冲突。
本文为了避免这种冲突，定义数组大小为[32][33]



本文方法的动机
SAT 计算的瓶颈在于数据移动。以聚合模式高效访问全局内存对算法性能至关重要。此外，设计减少为了减少数据移动，我们采用了寄存器缓存方法。问题在于如何在有效使用寄存器的同时避免争用。
线程间通信寄存器的技术（即shuffle指令）只能在单个 warp（CUDA 中一起执行的一组线程）内工作。因此，我们调整了算法，在warp级别进行扫描，同时避免warp内部通信。

最直接的SAT计算




Prefix Sum
Basic method


Kogge-Stone
http://lumetta.web.engr.illinois.edu/408-S20/slide-copies/ece408-lecture16-S20.pdf


Step1得到长度小于等于2的累加和
Step2得到长度小于等于4的累加和
Step3得到长度小于等于8的累加和

LF-scan
warp shuffle


  In theory, the LFscan achieves the highest computing efficiency with logN  stages and $\frac{NlogN}{2}$
 addition operations as Fig. 2c shows,


‘reduce (up-sweep) and down-sweep’
https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda



问题

  算法流程决定加法运算的次数和算法阶段数。
  数据存储、传递的方式(GPU显存访问模式)也会显著影响算法性能。


本文贡献

  使用寄存器存储中间数据。
  提出BRLT


方法
Caching Data Using Register Files
SAT的计算问题是内存限制的。
每个线程都先使用寄存器缓存数据。
并且warp中线程的通信泗洪shuffle操作完成。

GPU聚合访问
用于降低对Global Memory的访问成本。具体做法是，在同一个warp中的所有线程访问临近的内存位置。GPU可以将这些操作打包成一次数据传输，从而降低延迟、提升带宽。


  data向16 bits or 32 bits对齐。
  globalID = (x + width * y + width * height * z),对内存位置的访问和GlobalID一致（尤其是2D图像，y连续访问不是聚合访问）。




Google
Ch

问题回顾

计算前缀和在两个方向上进行。
但是：

  两个方向需要使用不同的kernel函数（不同的着色器程序，或者引入不同的分支）。
  列方向处理的数据不连续，无法实现聚合访问。


因此，SAT计算更常见的做法是Scan-transpose-scan。
接下来需要考虑矩阵转置是否是聚合操作。
矩阵转置
warp level

element level
在每个warp内部：

Method：直接做法

写入操作不是聚合操作。
本文提出了BRLT，在Shared memory中对warp中的数据进行转置。

BRLT
Block-Register-Local-Transpose Method
这是一种将数据从寄存器复制到共享内容再复制回寄存器的矩阵transpose方法。


这种方法的仅使用共享内存作为缓冲区，transpose操作是在寄存器-共享内存之间完成的；传统算法的操作是在共享内存中完成，并且需要从主存中加载数据。

Bank conflict
google
GPU共享内存以bank的形式被组织。N卡通常32banks，bank中数据单元大小为4或8。当一个warp中的不同线程访问到同一个bank时，会发生conflict，导致IO操作无法并行。

例如，bank number=4.该任务是一个矩阵转置任务，Clock0时，四个线程写入第一列：

此时发生bank conflict。
但是如果修改共享内存大小为4*5:



部分和计算

  将warp计算出的部分和存储在共享内存中。
  在共享内存中计算数据的前缀和。
  将数据从共享内存加载回对应的warp。


方法一：ScanRow-BRLT
Efficient Integral Image Computation on the GPU 2010中方法需要将行扫描的结果存储在全局内存中，transpose操作也在全局内存中完成。
本文中的方法:

  将输入2D图像的一块直接加载到block中,
  然后执行行扫描-BRLT-写回主存。因此转置操作在共享内存中完成。

如上图所示，每个block负责32行的数据，每个warp处理32*32的块。
每个线程读取32个数据，线程之间使用LF-scan（利用shuffle操作）。
warp之间的通信：
在一个线程中串行操作，复杂度O(n^2)：




思考

  warp是被调度的基本单元，但并不意味着不同warp之间有先后顺序，也不意味着warp被完整调度。
  为什么转置以后再写回主存，直接rigister-shared memory-rigister的模式完成两次算法IO更少。
  如何处理更大的图像。


方法二：BRLT-ScanRow
与方法1类似，但是先转置再执行scan操作。重复两次。但是论文指出，该方法使用串行扫描算法，并且这种方法效率更高。

warp之间使用共享内存通信，但是该方法的每个线程只需要一个位置的preSum，复杂度降低为O(n)





方法三：Register-based ScanRowColumn Method

每个block处理32行的数据，每个warp处理一行的数据。
例如warp0，扫描0-31号元素，使用shuffle操作传递到warp0的第二次扫描的第一个线程上。


                        </a>
                        <div class="info-post">
                                <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0" class="category">技术学习</a>
                            
                                <span class="date">· 2025-01-03</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        <li class="paginated-item">
                <div id="article_content">
                    <div class="thumbnail_zone">
                        
                            <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/Vulkan%20compute%20shader.html" class="thumbnail_post" loading="lazy" aria-label="thumbnail_post" style="background-image:url('https://paminerva.github.io/docs/LearnVulkan/images/02/F/hardware-model.png') !important"></a>
                        
                    </div>
                    <div class="box_contents">
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/Vulkan%20compute%20shader.html"><h1 class="title_post">Vulkan Compute Shader</h1></a>
                        <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/Vulkan%20compute%20shader.html" class="txt_post">
                            Reference

P.A. Minerva’s Vulkan Tutorial on Compute Shaders
vulkan tutorial
AMD opengpu
GPU Program Blog
Example for Compute Shader

Intro


  
    核心组成：GPU由数千个处理核心组成，这些核心专门用于执行由许多核心同时处理的单独任务。GPU通过并行执行相同的指令序列（描述特定任务）来实现高速处理大量数据。
  
  
    核心组织：这些核心被组织成多处理器（multiprocessors），能够在多个线程上并行执行相同的指令。这种硬件模型被称为SIMT架构（Single-Instruction, Multiple-Thread）。
  
  
    多处理器内存：每个多处理器包括以下几种类型的片上内存：

    
      32位寄存器，分配给核心。
      共享内存，由所有核心共享。
      只读常量缓存，加速从设备内存的只读区域读取。
      只读纹理缓存，加速从纹理内存空间读取。
    
  
  
    线程组和执行：多处理器创建、管理、调度并执行称为warp（或wavefront）的32或64个并行线程组。每个warp在同一程序地址开始，但具有自己的指令地址计数器和寄存器状态，因此可以独立分支和执行。
  
  
    线程块和warp调度：多处理器接收一个或多个线程块进行执行时，将它们划分为warps，并由warp调度器管理和调度。线程块到warp的划分是一致的，每个warp包含连续递增的线程ID。
  
  
    执行上下文和调度：每个warp的执行上下文在其整个生命周期内都保持在芯片上，因此从一个执行上下文切换到另一个没有成本。每个指令发出时，warp调度器可以选择一个准备好执行下一指令的warp，并向这些线程发出指令。
  


线程块（Thread Blocks）


  定义：线程块是一组在GPU上同时执行的线程。它是由程序员定义的，用于组织和执行并行任务。
  大小和形状：线程块的大小（即包含的线程数）和形状（如1D、2D或3D）可以根据特定的计算任务进行调整。
  资源共享：线程块内的线程可以共享一定量的快速访问内存（称为共享内存），并且可以进行同步操作。


Warp（线程束）


  定义：warp是线程块中的一小部分线程，这些线程在GPU上以单一的指令流同时执行相同的操作。在NVIDIA的GPU中，一个warp通常包含32个线程。
  硬件调度单位：warp是GPU硬件调度和执行的基本单位。GPU的warp调度器负责管理这些warp的执行。


线程块与Warp之间的关系


  线程块划分为Warp：当线程块被提交到GPU执行时，它被划分为多个warp。这个划分是自动进行的，基于warp的大小（如32个线程）。
  连续线程ID：每个warp包含具有连续线程ID的线程。例如，在32线程的warp中，第一个warp包含线程ID 0-31，第二个warp包含线程ID 32-63，依此类推。
  并行执行：线程块内的所有warp可以在GPU上并行执行，但每个warp内的线程同时执行相同的指令。
  执行效率：合理地组织线程块和warp对于实现高效的GPU并行计算至关重要。线程块的大小应该是warp大小的整数倍，以最大化GPU核心的利用率并减少空闲线程。
    SIMD vs SIMT
    GPU并不提供对SIMD的支持，因此考虑并行应该是SIMT，多个线程执行相同的指令。
  


GPU可以理解为一系列Multiprocessor的集合，如上图。Multiprocessor内部的processor可以共享一部分数据。
因此线程组的数量应该和multiprocessor数量对应(线程组可以多于multiprocessor数量)。
而warp是一组线程，是最小的调度单位。warp内的线程并行执行，但不同的warp之间是否并行取决于资源的分配（实际上这是由于某些操作会被挂起等待，转而执行其他的warp）。

CS
Thread Blocks：一个三维逻辑结构

Coding
Check maxComputeWorkGroupInvocations and maxComputeWorkGroupSize in VkPhysicalDeviceLimits 
查询线程组数量和线程组大小限制
线程组的数量由API制定，线程组的大小在GLSL代码中被指定

Sync
共享内存
// Array allocated in shared memory to be shared by all invocations in a work group.
// Check VkPhysicalDeviceLimits::maxComputeSharedMemorySize for the maximum 
// total storage size, in bytes, available for variables shared by all invocations in a work group.
shared vec4 gCache_0[256];


在一个线程组中的线程的执行很难确定先后顺序，如果多个线程访问到相同的数据，可能会造成线程冲突。
void main()
{
    ivec2 textureLocation = ivec2(gl_GlobalInvocationID.xy);

    // Read texel from input image at mipmap level 0 and
    // save the result in the shared memory
    gCache_0[gl_LocalInvocationID.x] = imageLoad(InputTex, textureLocation);

    // Wait for all invocations in the work group
    barrier();

    // OK!
    vec4 left = gCache_0[gl_LocalInvocationID.x - 1];
    vec4 right = gCache_0[gl_LocalInvocationID.x + 1];

    // ...
}

使用屏障保证数据写入完成。

barrier()函数的作用


  同步工作组内的着色器调用：在计算着色器中，barrier()函数确保在一个工作组（workgroup）内的所有着色器调用都到达这个屏障点之前，任何一个着色器调用都不会继续执行超过这个点的代码。
  在曲面细分控制着色器中的应用：barrier()函数也可以在曲面细分控制着色器中使用，以同步单个输入补丁的所有着色器调用。


控制流的一致性


  控制流必须是一致的：在计算着色器中使用barrier()时，控制流必须是一致的。这意味着如果任何一个着色器调用进入了一个条件语句，那么所有的调用都必须进入它。


barrier()与内存同步


  控制流和共享变量的同步：barrier()函数影响控制流，并同步对共享变量的内存访问（以及曲面细分控制输出变量）。
  其他内存访问：对于非共享变量的内存访问，barrier()函数并不能保证一个着色器调用在barrier()之前写入的值可以被其他调用在barrier()之后安全地读取。


使用内存屏障函数


  确保内存访问的顺序：为了确保一个着色器调用写入的值可以被其他调用安全地读取，需要同时使用barrier()和特定的内存屏障函数。
  内存屏障函数的作用：内存屏障函数用于对可被其他着色器调用访问的内存中的变量进行读写操作的排序。这些函数在被调用时，会等待调用者之前执行的所有读写操作的完成，然后再返回。


不同类型的内存屏障函数


  特定类型变量的内存屏障：如memoryBarrierAtomicCounter()、memoryBarrierBuffer()、memoryBarrierImage()和memoryBarrierShared()等函数，分别用于等待对原子计数器、缓冲区、图像和共享变量的访问的完成。
  全局内存屏障：memoryBarrier()和groupMemoryBarrier()函数用于等待对所有上述变量类型的访问的完成。
  着色器类型的可用性：memoryBarrierShared()和groupMemoryBarrier()只在计算着色器中可用，而其他函数在所有着色器类型中都可用。


例子：粒子系统
使用GPU更新顶点位置，避免了受到总线带宽的限制。
SSBO
需要一个能读能写的buffer，SSBO可以满足这一点。
flag为：
VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT

VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
Buffer type
. VK_BUFFER_USAGE_STORAGE_BUFFER_BIT

• Description: This flag indicates that the buffer can be used as a storage buffer. Storage buffers are used to store large blocks of data that shaders (especially compute shaders) can read from and write to.

• Common Use Case:

• It is commonly used in compute shaders or fragment shaders where you need random-access read and write operations.

• It’s suitable for large datasets that may change frequently, like results of computations or intermediate data.

• Access in Shaders:

• In GLSL (Vulkan’s shading language), a buffer marked with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT is typically accessed using the layout(std430) storage qualifier, like this:
• Both read and write operations are possible in shaders.

VK_BUFFER_USAGE_TRANSFER_SRC_BIT
• Description: This flag indicates that the buffer can be used as a source for data transfer operations. Specifically, this buffer can be used in a memory transfer operation, where data from this buffer will be copied to another buffer or image (e.g., via vkCmdCopyBuffer or vkCmdCopyBufferToImage).

• Common Use Case:

• When you want to copy data from one buffer to another buffer or image, the source buffer should be created with this flag.

• It’s useful when you’re doing staging operations: you might upload data to a buffer that’s visible to the CPU (with VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT), then transfer it to a GPU-only buffer with VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT.

VK_BUFFER_USAGE_VERTEX_BUFFER_BIT用于顶点着色器，VK_BUFFER_USAGE_STORAGE_BUFFER_BIT用于计算着色器的写入和读取。
VK_BUFFER_USAGE_TRANSFER_DST_BIT表明该buffer是数据复制的目的buffer。例如从staging buffer到该buffer。
VK_BUFFER_USAGE_TRANSFER_SRC_BIT表明该buffer是数据复制的起源。例如staging buffer。

Storage Image
借助SI可以完成对图片的操作，例如后处理、生成mip-maps等。

信号量和栅栏
计算cmd需要栅栏避免冗余提交（确保之前的
指令已经被执行再提交，cpu和gpu之间），计算管线和图形管线之间需要信号量，保证图形管线开始时计算任务已经完成（gpu内部）。

  [!note]
解释了为什么信号量以数组形式给出：
VkSemaphore waitSemaphores[] = { computeFinishedSemaphores[currentFrame], imageAvailableSemaphores[currentFrame] };


延伸：
Asynchronous compute 
[[TBDR]]

                        </a>
                        <div class="info-post">
                                <a href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0" class="category">技术学习</a>
                            
                                <span class="date">· 2024-03-12</span>
                            
                        </div>
                    </div>
                </div>
            </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        </ul>
    
</div>
<div class="pagination">
    <nav class="pagination-container">
        <button class="pagination-button" id="prev-button" aria-label="Previous page" title="Previous page">
            &lt;
        </button>
    
        <div id="pagination-numbers"></div>
      
        <button class="pagination-button" id="next-button" aria-label="Next page" title="Next page">
            &gt;
        </button>
    </nav>
</div>
                
            </div>
        </div>
        <div id="search">
    <div class="wave"></div>
    <div class="wave"></div>
    <div class="wave"></div>

    <div class="search-box">
        <mark>Touch background to close</mark>
        <div class="input-box">
            <input id="search-input" type="search" tabindex="1" spellcheck="false" placeholder="Search...">
            <button id="btn-clear">
                <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 384 512"><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"></path></svg>
            </button>
        </div>
        <ul id="search-result"></ul>
    </div>
</div>
    </body>
    <script defer src="/assets/js/background.js"></script>
<script defer src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }

    gtag('js', new Date());
    gtag('config', '');
</script>
    
        <script src="/assets/js/subject.js"></script>
    
    <script src="/assets/js/common.js"></script>
    <script defer>
    var posts = [];

    

        posts.push({
            'title'    : "Index",
            'path'     : "2D矢量图元绘制技术研究",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/2D%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%85%83%E7%BB%98%E5%88%B6%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "EasyVulkan",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/EasyVulkan/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "技术学习 > GPU通用计算",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "技术学习",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Index",
            'path'     : "模糊阴影视效研究",
            'type'     : "category",
            'tags'     : "",
            'url'      : "/%E6%A8%A1%E7%B3%8A%E9%98%B4%E5%BD%B1%E8%A7%86%E6%95%88%E7%A0%94%E7%A9%B6/index.html",
            'image'    : "/assets/img/thumbnail/empty.jpg",
            'date'     : "1900-01-01"
        });
    

        posts.push({
            'title'    : "Vulkan Compute Shader",
            'path'     : "技术学习 > GPU通用计算",
            'type'     : "post",
            'tags'     : "GPU, Vulkan, ComputeShader",
            'url'      : "/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/Vulkan%20compute%20shader.html",
            'image'    : "https://paminerva.github.io/docs/LearnVulkan/images/02/F/hardware-model.png",
            'date'     : "2024-03-12"
        });
    

        posts.push({
            'title'    : "How to compute integral image on GPU?",
            'path'     : "技术学习 > GPU通用计算",
            'type'     : "post",
            'tags'     : "user manual, markdown, writing format",
            'url'      : "/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/GPU%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/integral%20Image%E8%AE%A1%E7%AE%97.html",
            'image'    : "https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250102174554.png",
            'date'     : "2025-01-03"
        });
    

        posts.push({
            'title'    : "图像降采样",
            'path'     : "技术学习",
            'type'     : "post",
            'tags'     : "Image Processing, Vulkan, Opengl, 降采样",
            'url'      : "/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E5%83%8F%E9%99%8D%E9%87%87%E6%A0%B7.html",
            'image'    : "https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250112201138.png",
            'date'     : "2025-01-12"
        });
    

        posts.push({
            'title'    : "Vulkan初始化",
            'path'     : "EasyVulkan",
            'type'     : "post",
            'tags'     : "Vulkan, EasyVulkan",
            'url'      : "/EasyVulkan/Vulkan%E5%88%9D%E5%A7%8B%E5%8C%96.html",
            'image'    : "https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250124230354.png",
            'date'     : "2025-01-24"
        });
    

        posts.push({
            'title'    : "VMA",
            'path'     : "EasyVulkan",
            'type'     : "post",
            'tags'     : "Vulkan, EasyVulkan, VMA",
            'url'      : "/EasyVulkan/VMA.html",
            'image'    : "https://docs.vulkan.org/guide/latest/_images/memory_allocation_sub_allocation.png",
            'date'     : "2025-01-26"
        });
    

    searchPost(posts);

    
</script>
</html>
