---
title: "图像降采样"
tags:
    - Image Processing
    - Vulkan
    - Opengl
    - 降采样
date: "2025-01-12"
thumbnail: "https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250111165135.png" alt="image description"
bookmark: true
---

>最近的一个横向中涉及对图像进行降采样的问题，最近两周实现和对比了一些降采样的方法，在本文中进行归纳总结。
本文的主要内容包括：1.介绍几种常见的降采样方法。2.对比不同方法的性能。
亮点是对glGenerateMipmap函数的分析。

# 定义
图像降采样(Image Downsampling)是指通过减少图像的像素数量来降低图像分辨率的过程。具体来说，它是将高分辨率的原始图像转换为较低分辨率的图像，同时尽可能保持图像的视觉质量和关键信息。
<div style="text-align: center;">

    <img src="https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250111165135.png" alt="image description" style="max-width: 100%; height: auto;">

    <p>图 1：区域均值降采样。</p>

</div>

常见的图像降采样方法包括：
- 最近邻插值  选择最接近的像素值
- 双线性插值  使用周围4个像素的加权平均
- 双三次插值  使用周围16个像素的加权平均
- 区域平均  计算采样区域内所有像素的平均值

# 问题目标
- 将图像的分辨率降低到$\frac{W}{2^n} \times \frac{H}{2^n}$。
- 在保证图片质量的前提下，尽可能提高计算速度。
- 使用C++、OpenGL或Vulkan实现。

# 插值方法介绍
为了平衡计算速度和图片质量，本文主要研究双线性插值或区域平均。
## 双线性插值
### 图形API中的双线性插值
在OpenGL或Vulkan等图形API中，双线性插值被广泛的支持，例如在OpenGL中，可以使用`glTexImage2D`函数来创建一个纹理，并指定`GL_LINEAR`作为纹理过滤器，从而在片段着色器中使用双线性插值对该纹理进行采样。除了GL_LINEAR外，还包括：
- `GL_NEAREST`：最近邻插值
- `GL_NEAREST_MIPMAP_LINEAR`：根据bias参数选择两个mipmap层，mipmap层内部进行最近邻插值，mipmap层之间使用线性插值。
- `GL_NEAREST_MIPMAP_NEAREST`：选择最近的mipmap层，在单个mipmap中最近邻插值。

- `GL_LINEAR_MIPMAP_NEAREST`：选择最近的mipmap层，在单个mipmap中双线性插值。
- `GL_LINEAR_MIPMAP_LINEAR`：根据bias参数选择两个mipmap层，mipmap层内部进行双线性插值，mipmap层之间使用线性插值。

在Vulkan中，将图像绑定到描述符集时，可以为该图像创建采样器，可以为采样器指定类似于前文OpenGL提供的采样参数,具体包括：
- `VK_FILTER_NEAREST`：最近邻插值
- `VK_FILTER_LINEAR`：双线性插值

如果开启mipmap，则可以指定：
- `VK_SAMPLER_MIPMAP_MODE_NEAREST`：对mipmap进行最近邻插值
- `VK_SAMPLER_MIPMAP_MODE_LINEAR`：对mipmap进行双线性插值

### 双线性插值理论
<div style="text-align: center;">

    <img src="https://images2018.cnblogs.com/blog/683615/201809/683615-20180908115252513-747997808.png" alt="image description" style="max-width: 100%; height: auto;">

    <p>图 2：双线性插值。</p>

</div>

双线性插值需要使用最近的四个像素进行插值，计算公式如下：
$$
I(x, y) = (1 - dx) * (1 - dy) * I(0, 0) + dx * (1 - dy) * I(1, 0) + (1 - dx) * dy * I(0, 1) + dx * dy * I(1, 1)
$$
其中，$I(x, y)$是插值后的像素值，$I(0, 0)$、$I(1, 0)$、$I(0, 1)$、$I(1, 1)$是最近的四个像素值，$dx$和$dy$是插值点相对于最近四个像素点的偏移量。
# 
将双线性插值应用于采样时，如果将分辨率降低为原始分辨率的$\frac{1}{2}$，那么等价于对四个像素进行区域平均，即：
$$
I(0.5,0.5) = (1-0.5) * (1-0.5) * I(0, 0) + 0.5 * (1-0.5) * I(1, 0) + (1-0.5) * 0.5 * I(0, 1) + 0.5 * 0.5 * I(1, 1) \\
I(0.5,0.5) = \frac{I(0, 0) + I(1, 0) + I(0, 1) + I(1, 1)}{4} \phantom{* (1-0.5) * I(0, 0) + 0.5 * (1-0.5) * I(1, 0) + (1-0.5) * 0.5 * I(0, 1) + 0.5 * 0.5 * I(1, 1)}
$$
<div style="text-align: center;">

    <img src="https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250111174608.png" alt="image description" style="max-width: 100%; height: auto;">

    <p>图 3：图像分辨率降低一半时，双线性插值等价于区域平均。</p>

</div>

然而，当降采样比率较大时($\frac{width_{original}}{width_{downsampled}} > 2$)，双线性插值会“遗漏”一些像素，从而带来图像质量的显著损失。如下图所示，蓝色的像素是原始图像中的像素，深色的像素是降采样后对应回原图的区域，橙色圆形是该区域的中心，对橙色圆形进行双线性插值时参与的只有蓝色圆形所示的点，其他像素被“遗漏”。
<div style="text-align: center;">

    <img src="https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250111175256.png" alt="image description" style="max-width: 100%; height: auto;">

    <p>图 4：降采样样比率较大时，双线性插值会“遗漏”一些像素。</p>

</div>

因此，为了保证降采样图像的质量，逐级降采样是更好的选择。所谓逐级降采样，是指将图像先降采样到$\frac{1}{2}$，再降采样到$\frac{1}{4}$，再降采样到$\frac{1}{8}$，以此类推。

<div style="text-align: center;">

    <img src="https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250112012642.png
" alt="image description" style="max-width: 100%; height: auto;">

    <p>图 5：逐级降采样。</p>

</div>

这种逐级降采样的方式非常适合在图形管线中实现。在OpenGL中，我们可以通过两种方式来实现:
1. 使用`glGenerateMipmap`函数自动生成mipmap序列，这是最简单直接的方法
2. 将原始图像作为输入纹理，通过多次渲染并利用双线性插值采样到更小的目标图像上，逐步完成降采样过程

与OpenGL不同，Vulkan没有提供类似`glGenerateMipmap`的便捷函数。在Vulkan中，我们需要通过重复调用`vkCmdBlitImage`命令来手动生成每一级mipmap。虽然这种方式需要更多的代码，但也给了开发者更大的灵活性和控制权。
下文将对比这三种方式的时间和优缺点。

### 区域平均理论
区域平均是一种简单直观且计算高效的图像降采样方法。它通过以下步骤实现图像的降采样处理：

1. 根据目标图像尺寸，将原始图像划分为多个大小相等、互不重叠的矩形区域
2. 对每个矩形区域内的所有像素值进行算术平均计算
3. 将计算得到的平均值赋给降采样后图像中对应位置的像素

这种方法的一大优势在于其灵活性： 它可以通过**单次计算过程**将图像直接降采样到任意目标尺寸，而**不需要多次迭代**。这种特性使其在某些场景下具有明显的性能优势。
# 实现和对比

