---
title: "色彩空间错误导致图像亮度增加"
tags:
    - Color Space
    - Vulkan
    - Bug
date: "2025-02-09"
thumbnail: "https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/color_Conversion.png"
bookmark: true
---

# 正确处理sRGB色彩空间——记一次Vulkan图像过亮问题的排查

---

## 一、问题背景与现象

### 1.1 项目架构
最近完成了一个基于Vulkan的混合渲染程序，核心架构包含计算管线和图形管线：
- **计算管线**：使用 `VK_FORMAT_R32G32B32A32_SFLOAT` 格式的纹理作为输入/输出
- **图形管线**：通过相同格式的纹理进行采样，在片段着色器中将其渲染到屏幕

### 1.2 异常现象
程序运行时，屏幕上显示的图像**比原始素材显著更亮**，且在明暗过渡区域出现不自然的光晕效果。
<div markdown="0" style="text-align: center;">

<img src="https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/20250209152909.png" alt="image description" style="max-width: 100%; height: auto;">

<p style="text-align: center;">图 1:图片过亮</p>

</div>



---

## 二、问题排查过程

### 2.1 初步怀疑：Gamma校正问题
观察到图像过亮后，首先怀疑**Gamma校正未正确应用**。以下是关键检查步骤：

#### (1) 检查图像加载逻辑
```cpp
// 原始图像加载代码（发现问题）
int width, height, channels;
stbi_uc* pixels = stbi_load("example2048.png", &width, &height, &channels, STBI_rgb_alpha);
```
- **问题发现**：`STBI_rgb_alpha` 将PNG的sRGB值直接读入内存，未执行sRGB→Linear转换
- **根本原因**：图像数据以sRGB格式存储，但被当作线性值处理

#### (2) 验证交换链配置
```cpp
// 交换链颜色空间配置（默认值）
VkColorSpaceKHR colorSpace = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
```
- **关键发现**：交换链自动执行Linear→sRGB转换，但输入的纹理数据已经是sRGB。

---

<div markdown="0" style="text-align: center;">

<img src="https://obsidian-picture-1313051055.cos.ap-nanjing.myqcloud.com/Obsidian/color_Conversion.png" alt="image description" style="max-width: 100%; height: auto;">

<p style="text-align: center;">图 2:色彩空间转换错误</p>

</div>



## 三、技术原理：为什么冗余转换导致过亮？

### 3.1 sRGB与Linear空间的数学关系
sRGB采用近似Gamma 2.2的**非线性编码**（分段函数）：

$$
C_{sRGB} = \begin{cases}
12.92C_{linear}, & C_{linear} \leq 0.0031308 \\
1.055C_{linear}^{1/2.4} - 0.055, & \text{otherwise}
\end{cases}
$$

### 3.2 冗余转换的数学推导
假设原始sRGB值为 **0.5**（实际对应Linear值约为 **0.214**）：
1. **错误处理流程**：
   - 加载时未转换：`C_linear（误） = 0.5`
   - 交换链自动转换：`C_{final} = 1.055 × 0.5^{1/2.4} - 0.055 ≈ 0.735`
2. **正确值应为**：0.5（不执行任何转换）

**视觉差异**：0.735比0.5亮度提升47%，导致整体画面过亮。

---

## 四、解决方案与评估

### 4.1 方案一：修改交换链色彩空间
```cpp
// 使用PASS_THROUGH_EXT禁用自动转换
VkColorSpaceKHR colorSpace = VK_COLOR_SPACE_PASS_THROUGH_EXT;
```

### 4.2 方案二：片段着色器手动转换

```glsl
// 在片段着色器中添加转换逻辑
vec3 sRGBToLinear(vec3 c) {
    return mix(c/12.92, pow((c+0.055)/1.055, vec3(2.4)), step(0.04045, c));
}
void main() {
    vec4 color = texture(sampler, uv);
    color.rgb = sRGBToLinear(color.rgb);
    outColor = vec4(color.rgb, 1.0);
}
```

先将颜色从sRGB空间转换到线性空间，颜色输出时，硬件再将颜色从线性空间转换到正确的sRGB空间。



### 4.3 方案三：直接使用 sRGB 纹理格式（推荐给采样类纹理）

当纹理来源于 LDR 图片（PNG/JPEG 等，天然是 sRGB 编码）且仅用于“采样”时，最简洁和不易出错的方式是直接使用 sRGB 纹理格式，例如 `VK_FORMAT_R8G8B8A8_SRGB` 或 `VK_FORMAT_B8G8R8A8_SRGB`。

- **工作机制**：对 sRGB 格式的图像视图进行采样时，GPU 会在采样阶段自动执行 `sRGB → Linear` 解码，然后再做过滤与着色计算。
- **结果**：着色器里拿到的就是线性空间值，无需手动 `sRGBToLinear`，也避免了重复 Gamma 造成的过亮。

示例代码（省略错误检查）：

```cpp
// 1) 创建图像时使用 SRGB 格式（仅用于采样/渲染，不作为 storage image）
VkImageCreateInfo imageInfo{};
imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
imageInfo.imageType = VK_IMAGE_TYPE_2D;
imageInfo.format   = VK_FORMAT_R8G8B8A8_SRGB;  // 关键：SRGB 格式
imageInfo.extent   = {static_cast<uint32_t>(width), static_cast<uint32_t>(height), 1};
imageInfo.mipLevels = mipLevels;
imageInfo.arrayLayers = 1;
imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;
imageInfo.tiling  = VK_IMAGE_TILING_OPTIMAL;
imageInfo.usage   = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;

// 2) 视图格式保持 SRGB（采样时自动解码）
VkImageViewCreateInfo viewInfo{};
viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
viewInfo.image = textureImage;
viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
viewInfo.format = VK_FORMAT_R8G8B8A8_SRGB;     // 关键：SRGB 视图
viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
viewInfo.subresourceRange.baseMipLevel = 0;
viewInfo.subresourceRange.levelCount   = mipLevels;
viewInfo.subresourceRange.baseArrayLayer = 0;
viewInfo.subresourceRange.layerCount     = 1;

// 3) 着色器中无需手动转换
// vec4 color = texture(sampler2D, uv); // 这里拿到的已是线性空间
```

注意事项：
- **不要**将 sRGB 格式的图像用作 `storage image`（大多数设备不支持 `VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT`）。
- 纹理数据上传时，保持 8-bit 整数数据（如 `stbi_load` 的 `stbi_uc*`），SRGB 解码由采样器负责，**不要在 CPU 端先做 Gamma**。
- 若需要生成 mipmap，mip 也应基于 sRGB 视图生成（驱动会在采样域做正确的线性化后再过滤）。

### 4.4 方案选择建议（针对本文场景）
- **原始贴图/材质**：优先使用 sRGB 纹理（方案三），着色器保持线性运算；最终输出依赖交换链色彩空间。
- **计算管线产物（storage image 写入）**：保持线性格式（`UNORM` 或 `SFLOAT`），在图形管线中以线性格式采样；不要把线性数据当 sRGB 采样。
- 如果整个链路中既有“sRGB 来源贴图”也有“线性计算产物”，请分别以合适格式管理，不要混用一个图像在 sRGB/UNORM 视图间交替用于不同语义的数据。



## 五、延伸知识：常见色彩空间与应用

# Vulkan 色彩空间对应关系

| 色彩空间 | Gamma曲线 | 主要应用场景 | Vulkan对应枚举值 |
|----------|-----------|--------------|------------------|
| sRGB | ~2.2 | Web图像、消费级显示器 | `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` |
| Linear | 1.0 | 物理光照计算、HDR渲染 | `VK_COLOR_SPACE_PASS_THROUGH_EXT` |
| Adobe RGB | 2.2 | 专业摄影、印刷出版 | 无直接对应值 |
| DCI-P3 | 2.6 | 数字影院、高端视频制作 | `VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT` |
| Rec.2020 | 混合 | 8K/4K HDR电视 | `VK_COLOR_SPACE_BT2020_LINEAR_EXT`<br>`VK_COLOR_SPACE_BT2020_NONLINEAR_EXT` |
| scRGB（线性） | 1.0 | HDR合成、科学可视化 | `VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT` |

### 5.1 纹理格式基础知识（UNORM / SRGB / SFLOAT）

| 分类 | 典型格式 | 取值域 | 采样行为 | 可否作 storage image | 常见用途 |
|------|----------|--------|----------|----------------------|----------|
| UNORM（线性） | `R8G8B8A8_UNORM` | 0..1（量化到 8-bit） | 直接按线性值采样/过滤 | 通常支持 | 线性中间结果、G-Buffer、计算管线输出 |
| SRGB（非线性编码） | `R8G8B8A8_SRGB`/`B8G8R8A8_SRGB` | 0..1（sRGB 编码） | 采样时自动 sRGB→Linear | 一般不支持 | 来自 PNG/JPEG 的 LDR 贴图、UI 纹理 |
| 浮点（线性） | `R16G16B16A16_SFLOAT`/`R32G32B32A32_SFLOAT` | 宽动态范围 | 线性采样/高精度 | 通常支持 | HDR、物理光照、计算精度要求高的通道 |

关键要点：
- **sRGB 只在“采样”/“颜色附件写回”路径定义了编码转换语义**；
  - 采样：`sRGB → Linear` 自动执行；
  - 颜色附件写回：实现可将线性写入值转换为 sRGB 存储格式；
  - storage image：通常未定义/不支持。
- 同一物理图像若想创建不同格式的视图，必须在 `VkImageCreateInfo::flags` 中设置 `VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT`，且格式需属于同一兼容类。但请谨慎：
  - 用 sRGB 视图读取“线性数据”会被错误地当作 sRGB 再解码，导致画面偏暗。
  - 只有当底层数据确实是 sRGB 编码时，才应使用 sRGB 视图进行采样。

### 5.2 实战配置与排错清单
- **来自磁盘的 LDR 贴图**：图像/视图用 `*_SRGB`，采样拿到线性；不要再手动 `sRGBToLinear`。
- **中间缓冲/计算结果**：使用 `UNORM` 或 `SFLOAT`，线性采样；如要节省带宽可选 `R11G11B10_UFLOAT_PACK32` 等。
- **交换链**：常见为 `format=*_SRGB` 且 `colorSpace=VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`，负责最终 `Linear → sRGB`。
- **校验格式能力**：用 `vkGetPhysicalDeviceFormatProperties` 检查 `FORMAT_FEATURE_SAMPLED_IMAGE_BIT`、`COLOR_ATTACHMENT_BIT`、`STORAGE_IMAGE_BIT` 是否满足需求。
- **避免重复 Gamma**：出现“偏亮/偏暗”优先检查：贴图格式、图像视图格式、是否手动 Gamma、交换链色彩空间是否与期望匹配。

# 六、EasyVulkan中的色彩空间
在EasyVulkan中，可以在交换链创建前指定色彩空间：

```C++
swapchainManager->setPreferredColorSpace(VK_COLOR_SPACE_SRGB_NONLINEAR_KHR);
swapchainManager->createSwapchain(800, 600);
```

交换链创建时，会优先创建具有指定format和color_space的交换链图像，如果不存在同时满足的情况，则会**优先选择color_space**，然后匹配合适的fromat。

```C++
// First try to find a format with our preferred color space and SRGB format
for (const auto& availableFormat : availableFormats) {
    if (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &&
        availableFormat.colorSpace == m_preferredColorSpace) {
        return availableFormat;
    }
}

// If not found, try to find any format with our preferred color space
for (const auto& availableFormat : availableFormats) {
    if (availableFormat.colorSpace == m_preferredColorSpace) {
        return availableFormat;
    }
}
```